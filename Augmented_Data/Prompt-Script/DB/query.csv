code,prompt
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()

# Retrieve all instances present in the design block
insts = block.getInsts()

# Initialize an empty list to store the names of library cell type for each instance
masters_list = []

# Iterate over each instance in the design block
for inst in insts:
    # Retrieve the library cell type of the current instance
    master_type = inst.getMaster()
    # Get the name of the library cell type
    master_type_name = master_type.getName()
    # Append the name of the library cell type to the list
    masters_list.append(master_type_name)

# Return the list containing the names of library cell type for every instance
return masters_list",Give me the names of library cell type of every instance
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
loc = []
for inst in insts:
    # Append the location of the instance to the list
    loc.append(inst.getLocation())
return loc",Give methe location of every instance in the design and return it in a list called loc.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
placement_status_with_name = {}
# Iterate over each instance in the design block
for inst in insts:
        # Get the name of particular instance
        name = inst.getName()
        # Get the placement status of the instance
        status = inst.getPlacementStatus()
        # Add the respective instance name and its status 
        placement_status_with_name[name] = status
return placement_status_with_name",Get the name of every instance with its placement status as a dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
placed_instances = []
# Iterate over each instance in the design block
for inst in insts:
        # Check if this instance is placed 
        if inst.isPlaced()==True:
                # Append the instance name to the array 
                placed_instances.append(inst.getName())
return placed_instances",Get the names of every instance which are placed and return a list of names
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
level_of_instance = {}
# Iterate over each instance in the design block
for inst in insts:
        # Retrieve the name of the instance and its level, then store it in the dictionary
        level_of_instance[inst.getName()] = inst.getLevel()
return level_of_instance",Get the level of all instances with the instance name as a dictionary. Key of the dictionary is name of the instance and value is the level of the instance
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
const_name= []
# Iterate over each instance in the design block
for inst in insts:
        # Append the Const name of the instance
        const_name.append(inst.getConstName())
return const_name",Get all the Constant names of the instances and return as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
print("" name       | net_type | pin&wire_capacitance"")
# Retrieve all nets present in the design block
nets = block.getNets()
# Iterate over each net in the design block
for net in nets:
        # Get the net capacitance
        pin_and_wire_cap = timing.getNetCap(net, corner, timing.Max)
        # Get the name of the net
        net_name = net.getName()
        # Get the signal Type of the net
        net_type = net.getSigType()
        print(f""{net_name:<12}| {net_type:<9}| {pin_and_wire_cap:19.4e}"")","Write a code to Print the name of the net, its net type, and the wire capacitance of all the nets"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
print("" name        | rise_arrival_time | fall_arrival_time | rise_slack | fall_slack | slew"")
# Iterate over each instance in the design block
for inst in insts:
        # Get the pins associated with the instance
        inst_ITerms = inst.getITerms()
        # Iterate through all the pins
        for pin in inst_ITerms:
                # Check if the pin is in supply
                if design.isInSupply(pin):
                        continue
                # Get the pin name
                pin_name = design.getITermName(pin)
                # Get the pin rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Get the pin fall arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Get the pin rise slack
                pin_rise_slack = timing.getPinSlack(pin, timing.Fall, timing.Max)
                # Get the pin fall slack
                pin_fall_slack = timing.getPinSlack(pin, timing.Rise, timing.Max)
                # Get the pin slew
                pin_slew = timing.getPinSlew(pin)
                print(f""{pin_name:<12} | {pin_rise_arr:17.4e} | {pin_fall_arr:17.4e} | {pin_rise_slack:10.4e} | {pin_fall_slack:10.4e} | {pin_slew:6.4e}"") ","Write a code to print all the pin names, rising arrival time, fall arrival time, rise stack, fall stack and slew of all the pins"
"#Get the OpenROAD database
db = ord.get_db()
#Get the number of library cell types
return db.getNumberOfMasters()",Get the number of library cells in the library
"# Get the design block
block = ord.get_db_block()
# Get the die area of the design
area = block.getDieArea()
# Get the width and height of the die area
dx = area.dx()
dy = area.dy()
# Calculate the die area
die_area = dx*dy
# Return the calculated die area
return die_area",Get the die area
"# Get the design block
block = ord.get_db_block()
# Get the core area of the design
area = block.getCoreArea()
# Get the width and height of the core area
dx = area.dx()
dy = area.dy()
# Calculate the core area
core_area = dx*dy
# Return the calculated core area
return core_area",Get the core area
"# Get the design block
block = ord.get_db_block()
# Report global connection of the design
global_connection = block.reportGlobalConnect()
# Return the global connections
return global_connection",Report all the global connection rules
"# Get the design block
block = ord.get_db_block()
# Initialize a variable to store the total number of pins
total_pins = 0
# Get instances
insts = block.getInsts()

# Iterate over instances
for inst in insts:
    # Add the number of pins of the instance to the total
    total_pins += len(inst.getITerms())

# Return the total number of pins
return total_pins",Get the total number of pins
"# Get the design block
block = ord.get_db_block()
# Get instances
insts = block.getInsts()
# Initialize a list to store instance names
inst_name =[]

# Iterate over instances and append their names to the list
for inst in insts:
        inst_name.append(inst.getName())

# Return the list of instance names
return inst_name",List all the instances name
"# Get the design block
block = ord.get_db_block()
# Initialize a list to store clock nets
clock_nets = []
# Get all nets
nets = block.getNets()
# Iterate over nets
for net in nets:
    # Check if the net is a CLOCK net
    if net.getSigType() == 'CLOCK':
        # Check if the net is a CLOCK net
        clock_nets.append(net)
# Check if CLOCK nets exist
if len(clock_nets) > 0:
    return True
else:
    return False",Check if the design has any clock nets
"# Get the design block
block = ord.get_db_block()
# Initialize variables to count power and ground nets
power_nets = 0
ground_nets = 0
# Get all nets
nets = block.getNets()
# Iterate over nets
for net in nets:
    # Check if the net is a POWER net
    if net.getSigType() == 'POWER':
        power_nets += 1
    # Check if the net is a GROUND net
    elif net.getSigType() == 'GROUND':
        ground_nets += 1
# Return the counts of power and ground nets
return power_nets, ground_nets",Get the total number of power and ground nets
"# Get the chip associated with the design's block.

# Retrieve the design block
block = design.getBlock()  

# Get the chip associated with the design block.
chip = block.getChip()  

# Return the chip associated with the design block.
return chip  ",Give me the chip of a given block
"# Get the nets in a given block

# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Return the list of nets
return nets",Get all nets in a given block
design.getBlock().getName(),Get the name of the design block
"# Get the logic ports for a given block

# Get the design block
block = design.getBlock()

# Get all logic ports
logic_ports = block.getLogicPorts()

# Return the list of logic ports
return logic_ports",Get the logic ports for a given block
"# Get the location of all instances
# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through all instances
for inst in insts:
    # Print the instance name and its location
    print(inst.getName(), ""Location:"", inst.getLocation())",Get the location of all instances
"# Check if the instance 'FILLER_0_0_1' is placed or not

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check placement status
inst_name = 'FILLER_0_0_1'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",Check if the instance 'FILLER_0_0_1' placed or not
"# Get the children of 'FILLER_0_0_1' instance

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance whose children are to be retrieved
inst_name = 'FILLER_0_0_1'

# Initialize a list to store children instances
children = []

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Get the children instances of the target instance
        children = inst.getChildren()
        break

# Return the list of children instances
return children",Get the children of 'FILLER_0_0_1' instance
"# Get the design block
block = ord.get_db_block()
# Get all nets
nets = block.getNets()
# Initialize variables to track the net with the maximum capacitance
max_cap_net = None
max_cap = float('-inf')
# Iterate over nets
for net in nets:
    # Get the total capacitance of the net
    cap = timing.getNetCap(net, corner, timing.Max)
    # Check if the capacitance of the current net is greater than the maximum capacitance found so far
    if cap > max_cap:
        # Update the maximum capacitance and the corresponding net
        max_cap = cap
        max_cap_net = net
# Return the net with the maximum capacitance
return max_cap_net.getName()",Identify the nets with the highest capacitance
"# Get the design block
block = ord.get_db_block()
# Find the instance named ""split30""
return block.findInst(""split30"")",Find instance split30
"# Get the design block
block = ord.get_db_block()        
# Get all nets
nets = block.getNets()
# Define the fanout threshold
gt_fanout = 10
# Initialize a list to store nets with fanout greater than the threshold
net_fanout = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) > gt_fanout:
                 # Append the net name and its fanout to the list
                 net_fanout.append([net_name, len(output_pins)])
# Return the list of nets with fanout greater than the threshold
return net_fanout",Give me a list of nets with a fanout greater than 10
"# Get the design block
block = ord.get_db_block()
# Get all nets
nets = block.getNets()
# Initialize variables to store maximum fanout and its corresponding net
max_fanout = 0
# Lists to store net names and their corresponding fanouts
net_fanout_list = []
net_name_list = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
         # Append the net name and its fanout to the respective lists
         net_name_list.append(net_name)        
         net_fanout_list.append(len(output_pins))
# Find the maximum fanout
max_fanout = max(net_fanout_list)
# Find the index of the net with the maximum fanout
max_fanout_index = net_fanout_list.index(max_fanout)
# Get the name of the net with the maximum fanout
max_fanout_net = net_name_list[max_fanout_index]
# Return the net with the maximum fanout
return max_fanout_net",Give me a list of nets with the maximum fanout 
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Initialize a list to store unique name of library cell types
masters_list = []
# Iterate over instances
for inst in insts:
        # Get the master associated with the instance
        mast = inst.getMaster()
        mast_name = mast.getName()        
        # Check if the library cell name is not already in the list
        if mast_name not in masters_list:
                # Append the library cell name to the list
                masters_list.append(mast_name)
# Return the list of unique library cell names
return masters_list",List all the library cells used
"# Get the design block
block = ord.get_db_block()
# Get the total number of connections (nets)
total_connections = len(block.getNets())
# Return the total number of connections
return total_connections",Get the total number of connections (nets)
"# Get all the input/output nets for a given block

# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Initialize a list to store input/output nets
io_nets = []

# Iterate through all nets
for net in nets:
    # Check if the net is an input/output net
    if net.isIO():
        # If it's an input/output net, add it to the list
        io_nets.append(net)

# Return the list of input/output nets
return io_nets",get all the input output nets for a given block
"# Get a list of all the output pins

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store output pins
output_pins_list = []

# Iterate through all instances
for inst in insts:
    # Get all input pins (ITerms) of the instance
    pins = inst.getITerms()
    # Iterate through all input pins
    for pin in pins:
        # Check if the pin is an output signal
        if pin.isOutputSignal():
            # If it's an output signal, add it to the list
            output_pins_list.append(pin)

# Return the list of output pins
return output_pins_list",get a list of all the output pins
"#Give me all nets connecting to the instance '_411_'

# Instance name to search for
inst_name = ""_411_""

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a variable to store the nets of the instance
nets = None

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Get all pins (ITerms) of the instance and extract their associated nets
        nets = [pin.getNet() for pin in inst.getITerms()]
        break

# Return the nets of the instance
return nets
",Give me all nets connecting to the instance '_411_'
"# Get weights of all the instances

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store weights of instances
inst_weight_dict = {}

# Iterate through all instances
for inst in insts:
    # Get the instance name
    name = inst.getName()
    # Check if the instance name is not already in the dictionary
    if name not in inst_weight_dict:
        # If not, add the instance name and its weight to the dictionary
        inst_weight_dict[name] = inst.getWeight()

# Return the dictionary containing weights of instances
return inst_weight_dict",get Weights of all the instances
"# Get length and width of the Bounding Box of the instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Get the length and width of the Bounding Box of the instance
length = inst.getBBox().getLength()
width = inst.getBBox().getWidth()

# Return the length and width
return (length, width)
",get length and width of the bounding Box of the instance ''_411_'
"# Get source type of all the instances on level 1

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store source types of instances on level 1
lvl1_inst_src_type = {}

# Iterate through all instances
for inst in insts:
    # Check if the instance is on level 1
    if inst.getLevel() == 1:
        # Add the instance name and its source type to the dictionary
        lvl1_inst_src_type[inst.getName()] = inst.getSourceType()

# Return the dictionary containing source types of instances on level 1
return lvl1_inst_src_type
",get source type of all the instance on level 1
"# Set the placement status of the instance '_411_' to 'UNPLACED'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Set the placement status of the instance to 'UNPLACED'
inst.setPlacementStatus('UNPLACED')
",set the placement Status of the instance '_411_' to 'UNPLACED'
"# Get all the blockages

# Get the design block
block = design.getBlock()

# Return all blockages
return block.getBlockages()",get all the blockages
"# Reset the tapcell in the design

# Get the tapcell in the design
tapcell = design.getTapcell()

# Reset the tapcell
tapcell.reset()",reset the tapcell in the design
"# Retrieve the capacitor-coupled segments

# Get the design block
block = design.getBlock()

# Return the capacitor-coupled segments
return block.getCCSegs()",retrieve the capacitor-coupled segments
"# Get the sites of rows

# Get the design block
block = design.getBlock()

# Get all rows
rows = block.getRows()

# Initialize a dictionary to store row names and their corresponding sites
row_site_dict = {}

# Iterate through all rows
for row in rows:
    # Add the row name and its site to the dictionary
    row_site_dict[row.getName()] = row.getSite()

# Return the dictionary containing row names and their sites
return row_site_dict",get the sites of rows
"# Get the height and width of the sites of each row

# Get the design block
block = design.getBlock()

# Get all rows
rows = block.getRows()

# Initialize a dictionary to store row names and their corresponding site dimensions
row_site_dict = {}

# Iterate through all rows
for row in rows:
    # Check if the row has a site
    if row.getSite():
        # Add the row name and its site dimensions to the dictionary
        row_site_dict[row.getName()] = [row.getSite().getHeight(), row.getSite().getWidth()]

# Return the dictionary containing row names and their site dimensions
return row_site_dict",get the height and width of the sites of each row
"# Get the location, orientation, direction, and spacing of rows

# Get the design block
block = design.getBlock()

# Get all rows
rows = block.getRows()

# Iterate through all rows
for i in range(len(rows)):
    row = rows[i]
    # Print row information
    print(""Row"", i, row.getName())
    print(""Location:"", row.getOrigin())
    print(""Rotation:"", row.getOrient())
    print(""Direction:"", row.getDirection())
    print(""Block spacing:"", row.getSpacing())
","get the location, rotation, direction and spacing of rows"
"# Get the rows with hybrid sites

# Get the design block
block = design.getBlock()

# Get all rows
rows = block.getRows()

# Initialize a list to store rows with hybrid sites
hybrid_row_site = []

# Iterate through all rows
for i in range(len(rows)):
    row = rows[i]
    site = row.getSite()
    # Check if the site is hybrid
    if site.isHybrid():
        # Append the row and its site to the list
        hybrid_row_site.append((row, site))

# Return the list of rows with hybrid sites
return hybrid_row_site",get the rows with hybrid sites
"# Get all the instances and their halos

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store instances and their halos
inst_halos = {}

# Iterate through all instances
for inst in insts:
    # Add the instance name and its halo to the dictionary
    inst_halos[inst.getName()] = inst.getHalo()

# Return the dictionary containing instances and their halos
return inst_halos",get all the instances and there halos
"# Get the instances and their respective regions

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store instances and their regions
inst_regions = {}

# Iterate through all instances
for inst in insts:
    # Add the instance name and its region to the dictionary
    inst_regions[inst.getName()] = inst.getRegion()

# Return the dictionary containing instances and their regions
return inst_regions",get the instances and their respective regions
"# Get all the do not touch instances and set do not touch to true if false for instances

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store do not touch instances
do_not_touch_elements = {}

# Iterate through all instances
for inst in insts:
    # Check if the instance is marked as do not touch
    if inst.isDoNotTouch():
        # Add the instance to the dictionary
        do_not_touch_elements[inst.getName()] = inst
    else:
        # Set do not touch to true for instances marked as false
        inst.setDoNotTouch(True)

# Return the dictionary containing do not touch instances
return do_not_touch_elements",get the all the do not touch instance and set do not touch to true if false for instances 
"# Set the EcoCreate and EcoDestroy for instance '_411_' to true

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Set EcoCreate and EcoDestroy to true
inst.setEcoCreate(True)
inst.setEcoDestroy(True)

# Return the modified instance
return inst",set the EcoCreate and EcoDestroy for instance '_411_' true
"# Mark the first output nets of the instances '_411_' and 'input1'

# Get the design block
block = design.getBlock()

# Find the instances '_411_' and 'input1'
inst1 = block.findInst('_411_')
inst2 = block.findInst('input1')

# Mark the first output net of instance '_411_'
inst1.getFirstOutput().getNet().setMark(True)

# Mark the first output net of instance 'input1'
inst2.getFirstOutput().getNet().setMark(True)
",mark the first output nets of the instances '_411_' and 'input1'
"# Get the nets that are disconnected from RC network

# Get the design block
block = design.getBlock()

# Get all the nets
nets = block.getNets()

# Initialize a list to store RC disconnected nets
rc_disconnected_nets = []

# Iterate through all the nets
for net in nets:
    # Check if the net is RC disconnected
    if net.isRCDisconnected():
        # Add the net to the list
        rc_disconnected_nets.append(net)

# Return the list of RC disconnected nets
return rc_disconnected_nets",Get the nets that are disconnected from RC network
"# Disconnect the nets of the instance 'input1' from the RC network

# Get the design block
block = design.getBlock()

# Find the instance with name 'input1'
inst = block.findInst('input1')

# Get the pins of the instance
pins = inst.getITerms()

# Iterate through the pins
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    if net:
        # Set the RC disconnected flag for the net
        net.setRCDisconnected(True)
",Disconnect the nets of the instance 'input1' from the RC network
"# Get the points of the placement bounding box of the library cell of the instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the library cell associated with the instance
master = inst.getMaster()

# Get the placement bounding box of the library cell
placement_boundary = master.getPlacementBoundary()

# Return the points of the placement bounding box
return placement_boundary.getPoints()
",get the points of the placement bounding box of the library cell of the instance '_411_'
"# Clear user flags of instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Clear user flags 1, 2, and 3 of the instance
inst.clearUserFlag1()
inst.clearUserFlag2()
inst.clearUserFlag3()",clear user flags of instance '_411_'
"# Check if the instance '_411_' is marked as an end cap cell.

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Check if the instance is marked as an end cap
return inst.isEndCap()",Check if the instance '_411_' is marked as an end cap cell.
"# Map nets to the wires

# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Initialize a dictionary to store net-wire mappings
net_wire_dict = {}

# Iterate through all nets
for net in nets:
    # Get the name of the net
    net_name = net.getName()
    
    # If the net name is not already in the dictionary, initialize an empty list
    if net_name not in net_wire_dict:
        net_wire_dict[net_name] = []
    
    # Append the wire connected to the net to the list in the dictionary
    net_wire_dict[net_name].append(net.getWire())

# Return the net-wire dictionary
return net_wire_dict",map nets to the wires
"# Get the MTerms of the master cell of the instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Return the MTerms
return mterms",get the MTerms of the master cell of the instance '_411_'
"# Get the IoType of the pins of the instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",get the IoType of the pins of the instance '_411_'
"block = design.getBlock()
insts = block.getInsts()
inst_list = []
for inst in insts:
    if not inst.getMaster().isCore():
        inst_list.append(inst)
return inst_list",get the instances whose masters are not of type CORE
"# Get the number of masks of each layer

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the number of masks for each layer
num_masks = {}

# Iterate through all layers
for layer in layers:
    # Store the number of masks for each layer
    num_masks[layer.getName()] = layer.getNumMasks()

# Return the dictionary containing the number of masks for each layer
return num_masks",get the number of masks of each layer
"# Get the clearance measure

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return the clearance measure
return tech.getClearanceMeasure()",get the measure system
"# Check LEF USEMINSPACING is set or not

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return whether UseMinSpacingObs is set in the technology
return tech.getUseMinSpacingObs()",Check LEF USEMINSPACING is set or not
"# Get the layers if they are set as isRectOnly

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a list to store layers are set as RectOnly
rect_layers = []

# Iterate through all layers
for layer in layers:
    # Check if the layer is set as RectOnly
    if layer.isRectOnly():
        # Append the rectangle-only layer to the list
        rect_layers.append(layer)

# Return the list of rectangle-only layers
return rect_layers",Get the layers if they are set as isRectOnly
"# Get the alias of all the layers

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the Alias of each layer
layer_alias = {}

# Iterate through all layers
for layer in layers:
    # Store the Alias of each layer
    layer_alias[layer.getName()] = layer.getAlias()

# Return the dictionary containing the Alias of all layers
return layer_alias",Get the alias of all the layers
"# Set the alias of the layers by the name convention ''layer i"" where i is the index of the layer

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the Alias of each layer
layer_alias = {}

# Iterate through all layers
for layer in layers:
    # Construct the Alias using the layer index
    alias = ""Layer "" + str(layer.getNumber())
    
    # Set the Alias of the layer
    layer.setAlias(alias)
    
    # Store the Alias of the layer in the dictionary
    layer_alias[layer.getName()] = alias

# Return the dictionary containing the updated Alias of layers
return layer_alias
","Set the Alias of the layers by the name convention ''layer i"" where i is the index of the layer"
"# Get LEF version

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return the LEF version of the technology
return tech.getLefVersion()",Get LEF version
"# Get LEF version as a string

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return the LEF version of the technology as a string
return tech.getLefVersionStr()",Get LEF version as a string
"# Get the resistance of all the layers

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the resistance of each layer
layer_resistance = {}

# Iterate through all layers
for layer in layers:
    # Get the resistance of the layer and store it in the dictionary
    layer_resistance[layer.getName()] = layer.getResistance()

# Return the dictionary containing the resistance of each layer
return layer_resistance",Get the resistance of all the layers
"# Get edge capacitance of all the layers

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the edge capacitance of each layer
layer_edge_capacitance = {}

# Iterate through all layers
for layer in layers:
    # Get the edge capacitance of the layer and store it in the dictionary
    layer_edge_capacitance[layer.getName()] = layer.getEdgeCapacitance()

# Return the dictionary containing the edge capacitance of each layer
return layer_edge_capacitance",get edge capacitance of all the layers
"# Get the upper and lower layer of the layer 'metal5'

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Find the layer 'metal5'
layer = tech.findLayer('metal5')

# Return the upper and lower layer of 'metal5'
return (layer.getUpperLayer(), layer.getLowerLayer())",get the upper and lower layer of the layer 'metal5'
"# Check if instance '_411_' is buffer and if it is an End Cap cell
block = design.getBlock()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Get the master of the instance
master = inst.getMaster()

# Check if the design is buffer for the master and if the master is End Cap
return design.isBuffer(master) and master.isEndCap()",Check if instance '_411_' is buffer and if it is an End Cap cell
"# Get the instances whose masters are of type sequential and make the master of instance '_411_' sequential

block = design.getBlock()

# Get all instances
insts = block.getInsts()

# List to store sequential instances
seq_insts = []

# Iterate through instances
for inst in insts:
    # Get the master of the instance
    master = inst.getMaster()
    
    # Check if the instance is '_411_'
    if inst.getName() == '_411_':
        # Make the master of instance '_411_' sequential
        master.setSequential(True)
    
    # Check if the master is of type sequential
    if master.isSequential():
        seq_insts.append(inst)

# Return sequential instances
return seq_insts
",Get the instances whose masters are of type sequential and make the master of instance '_411_' sequential
"# Check if the instance '411' has any pin set as clocked
block = design.getBlock()

# Find the instance '411'
inst = block.findInst('_411_')

# Get all pins of the instance
pins = inst.getITerms()

# List to store pins set as clocked
clocked_ports = []

# Check if any pin is set as clocked
for pin in pins:
    if pin.isClocked():
        clocked_ports.append(pin)

# Return clocked ports
return clocked_ports",Check if the instance '411' has any pin set as clocked
"# Display the location, orient, direction, and spacing of each row
block = design.getBlock()
rows = block.getRows()

# Print table header
print(""{:<15} {:<15} {:<15} {:<15}"".format(""Row Name"", ""Location"", ""Direction"", ""Spacing""))

# Print data in a table format
for row in rows:
    location = str(row.getOrigin())
    direction = str(row.getDirection())
    spacing = str(row.getSpacing())
    
    print(""{:<15} {:<15} {:<15} {:<15}"".format(row.getName(), location, direction, spacing))","Display the location, orient, direction, and spacing of each row"
"# Get the rows with 'MX' orient and get the instances and the first output pin of all instances
block = design.getBlock()
rows = block.getRows()
insts = block.getInsts()

# Initialize dictionaries to store the results
output_pins_dict = {}
MX_rows = []

# Iterate over rows to find those with 'MX' rotation
for row in rows:
    if row.getOrient() == ""MX"":
        MX_rows.append(row)

# Iterate over instances to find their output pins
for inst in insts:
    if inst.getFirstOutput():
        output_pins_dict[inst.getName()] = inst.getFirstOutput()

# Return the rows with 'MX' orientation and output pins of instances
return (MX_rows, output_pins_dict)",Get the rows with 'MX' rotation and get the instances and the first output pin of all instances.
"# Get all the instances and their halos and regions in a dictionary
block = design.getBlock()
insts = block.getInsts()
inst_halo_region_dict = {}

# Iterate over instances to collect their halos and regions
for inst in insts:
    inst_halo_region_dict[inst.getName()] = (inst.getHalo(), inst.getRegion())

# Return the dictionary with instance names as keys and a tuple of halo net and region as values
return inst_halo_region_dict",Get all the instances and their halos and regions in a dictionary with the instance name as the key and a tuple of halo net and region as value
"# Get the all the do not touch instances and set do not touch to true for pad instances
# Also, set the EcoCreate and EcoDestroy for instance '_411_' to True.

block = design.getBlock()
insts = block.getInsts()
dnt_insts = []

# Iterate over instances to set 'Do Not Touch' for pads and collect do not touch instances
for inst in insts:
    if inst.isPad():
        inst.setDoNotTouch(True)
        
    if inst.isDoNotTouch():
        dnt_insts.append(inst)
    
    #set the EcoCreate and EcoDestroy for instance '_411_' true.
    if inst.getName() == ""_411_"":
        inst.setEcoCreate(True)
        inst.setEcoDestroy(True)
        
return dnt_insts",Get the all the do not touch instances and set do not touch to true for pad instances and set the EcoCreate and EcoDestroy for instance '_411_' to True.
"# Mark the first output nets of the instances '411' and 'input1' and set RC disconnected to True for the nets.

# Get the block of the design
block = design.getBlock()

# Find the instances '411' and 'input1'
inst1 = block.findInst(""_411_"")
inst2 = block.findInst(""input1"")

# Mark the first output nets of the instances and set RC disconnected true for the nets
inst1.getFirstOutput().getNet().setMark(True)
inst2.getFirstOutput().getNet().setMark(True)

# Set RC disconnected true for the net of the first output of instance '411'
inst1.getFirstOutput().getNet().setRCDisconnected(True)

# Set RC disconnected true for the net of the first output of instance 'input1'
inst2.getFirstOutput().getNet().setRCDisconnected(True)",Mark the first output nets of the instances '411' and 'input1' and set RC disconnected to True for the nets.
"# Set RC disconnected true for the nets of the instance 'input1'
block = design.getBlock()
inst = block.findInst('input1')
nets = [pin.getNet() for pin in inst.getITerms()]
for net in nets:
    if net:
        net.setRCDisconnected(True)

# Get the upper-left, lower-left, lower-right, upper-right coordinates of the placement bounding box of the master cell of the instance '411'
placement_boundary = inst.getMaster().getPlacementBoundary()
coordinates = {
    ""ul"": placement_boundary.ul(),
    ""ll"": placement_boundary.ll(),
    ""lr"": placement_boundary.lr(),
    ""ur"": placement_boundary.ur()
}
return coordinates","Set the RC disconnected true for the nets of the instance 'input1' and get the upper-left, lower-left, lower-right, upper-right coordinates of the placement bounding box of the master cell of the instance '411'."
"# Get the current block of the design
block = design.getBlock()

# Find the instance with the name '_411_'
inst = block.findInst('_411_')

# Get the placement bounding box of the master cell of the instance
placement_boundary = inst.getMaster().getPlacementBoundary()

# Get the points of the placement bounding box
points = placement_boundary.getPoints()

# Clear user flag 1 of the instance
inst.clearUserFlag1()

# Clear user flag 2 of the instance
inst.clearUserFlag2()

# Clear user flag 3 of the instance
inst.clearUserFlag3()

# Return the points of the placement bounding box
return points",Get the points of the placement bounding box of the master cell of the instance '411' and clear user flags of instance '_411_'.
"# Get the current block of the design
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store coordinates for each master cell
coordinates = {}

# Iterate through each instance
for inst in insts:
    # Get the master cell of the instance
    master = inst.getMaster()
    
    # Get the placement bounding box of the master cell
    placement_boundary = master.getPlacementBoundary()
    
    # Check if the master cell name is not already in the coordinates dictionary
    if master.getName() not in coordinates:
        # Store the center x, y coordinates, and minimum and maximum x, y coordinates in the dictionary
        coordinates[master.getName()] = {
            ""center"": [placement_boundary.xCenter(), placement_boundary.yCenter()],
            ""min"": [placement_boundary.xMin(), placement_boundary.yMin()],
            ""max"": [placement_boundary.xMax(), placement_boundary.yMax()]
        }

# Return the dictionary containing coordinates for each master cell
return coordinates","Get the center x, y and minimum and maximum x, y coordinates of the placement bounding box of the master cell of the all instance."
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Dictionary to store spacing and number of masks for each layer
spacing_and_mask = {}

# Iterate through each layer in the technology
for layer in layers:
    # Store the spacing and number of masks for the current layer in the dictionary
    spacing_and_mask[layer.getName()] = {
        ""spacing"": layer.getSpacing(),
        ""masks"": layer.getNumMasks()
    }

# Return the dictionary containing spacing and number of masks for each layer
return spacing_and_mask
",Get the spacing and the number of masks of each layer
"# Get the current block of the design
block = design.getBlock()

# Get all blockages
blockages = block.getBlockages()

# Get all nets
nets = block.getNets()

# List to store RC disconnected nets
rc_disconnected_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is RC disconnected
    if net.isRCDisconnected():
        # Append the net to the list of RC disconnected nets
        rc_disconnected_nets.append(net)

# Find the instance 'rebuffer7'
inst = block.findInst('rebuffer7')

# Get the MTerms of the master cell of instance 'rebuffer7'
mterms = inst.getMaster().getMTerms()

# Return a tuple containing blockages, RC disconnected nets, and MTerms
return (blockages, rc_disconnected_nets, mterms)","Get all the blockages and get the nets that are RC disconnected, followed by getting the MTerms of the master cell of the instance 'rebuffer7'."
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Define the direction for the layers
direction = 'HORIZONTAL'

# List to store horizontal tech layers and their capacitance
horizontal_layers = []

# Iterate through each layer in the technology
for layer in layers:
    # Check if the layer direction is HORIZONTAL
    if layer.getDirection() == direction:
        # Append the layer and its capacitance to the list of horizontal layers
        horizontal_layers.append((layer, layer.getCapacitance())) 

# Retrieve the clearance measure
clearance_measure = tech.getClearanceMeasure()

# Get the setting of UseMinSpacingObs in the tech file
min_space_obs = tech.getUseMinSpacingObs()

# Construct a dictionary containing horizontal layers, clearance measure, and minimum spacing obstacle
result = {
    ""horizontal_layers"": horizontal_layers,
    ""clearance_measure"": clearance_measure,
    ""min_space_obs"": min_space_obs
}

# Return the result dictionary
return result","Get the horizontal layers and their capacitance, then retrieve the clearance measure system and check if UseMinSpacingObs is set for this technology"
"# Get the current block of the design
block = design.getBlock()

# Get rows and nets
rows = block.getRows()
nets = block.getNets()

# Dictionary to store row information with row index as key
row_info_dict = {}

# Dictionary to store sites of rows with row name as key
row_site_dict = {}

# Dictionary to map nets to wires
net_wire_dict = {}

# Iterate through each row
for i in range(len(rows)):
    row = rows[i]
    # Store row information in the row_info_dict
    row_info_dict[i] = {
        ""Location"": row.getOrigin(),
        ""Rotation"": row.getOrient(),
        ""Direction"": row.getDirection(),
        ""Spacing"": row.getSpacing()
    }
     
    # Store site of the row in the row_site_dict
    row_site_dict[row.getName()] = row.getSite()

# Iterate through each net
for net in nets:
    # Map net name to its wire
    net_wire_dict[net.getName()] = net.getWire()

# Return a tuple containing row information, row sites, and net wire mappings
return (row_info_dict, row_site_dict, net_wire_dict)","Get the location, rotation, direction, and spacing of rows as a dictionary with row index as key and get the sites of rows, followed by a dictionary with nets as keys and their wires as values."
"# Get the tapcell and reset it
tap_cell = design.getTapcell()
tap_cell.reset()

# Get the current block of the design
block = design.getBlock()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Set the placement status of the instance to 'UNPLACED'
inst.setPlacementStatus('UNPLACED')

# Retrieve the capacitor-coupled segments
cc_segs = block.getCCSegs()

# Return the coupling capacitance segments
return cc_segs","reset the tapcell, set the placement Status of the instance '_411_' to 'UNPLACED' and retrieve the capacitor-coupled segments of the bock"
"# Get the tapcell in the design and reset it
tap_cell = design.getTapcell()
tap_cell.reset()

# Get the current block of the design
block = design.getBlock()

# Return all blockages
return block.getBlockages()",Get all the blockages and reset the tapcell in the design.
"# Get the current block of the design
block = design.getBlock()

# Find the instance '_411_' and 'input1'
inst1 = block.findInst('_411_')
inst2 = block.findInst('input1')

# Mark the first output nets of the instances '_411_' and 'input1'
inst1.getFirstOutput().getNet().setMark(True)
inst2.getFirstOutput().getNet().setMark(True)

# Get the placement bounding box of the master cell of the instance '_411_'
placement_boundary = inst1.getMaster().getPlacementBoundary()

# Extract coordinates of the placement bounding box
coordinates = {
    ""ul"": placement_boundary.ul(),
    ""ll"": placement_boundary.ll(),
    ""lr"": placement_boundary.lr(),
    ""ur"": placement_boundary.ur()
}

# Return the coordinates
return coordinates","Mark the first output nets of the instances '_411_' and 'input1' and get the ul, ll, lr, ur coordinates of the placement bounding box of the master cell of the instance '_411_'."
"# Get the current block of the design
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Define the direction for the layers
direction = 'HORIZONTAL'

# List to store horizontal tech layers and their capacitance
horizontal_layers = []

# List to store instances whose masters are not of type CORE
non_core_master_insts = []

# Iterate through each instance
for inst in insts:
    # Check if the master cell of the instance is not of type CORE
    if not inst.getMaster().isCore():
        # Append the instance to the list of non-core master instances
        non_core_master_insts.append(inst)

# Iterate through each layer in the technology
for layer in layers:
    # Check if the layer direction is HORIZONTAL
    if layer.getDirection() == direction:
        # Append the layer and its capacitance to the list of horizontal layers
        horizontal_layers.append((layer, layer.getCapacitance()))

# Reset the tapcell
tap_cell = design.getTapcell()
tap_cell.reset()

# Return a tuple containing non-core master instances and horizontal layers
return (non_core_master_insts, horizontal_layers)","Get the instances whose masters are not of type CORE and get the horizontal tech layers and their capacitance, followed by resetting the tapcell"
"# Get the layersthat are set as RectOnly
# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a list to store layers that are set as RectOnly
rect_layers_alias = []

# Iterate through all layers
for layer in layers:
    # Check if the layer is set as RectOnly
    if layer.isRectOnly():
        # Append the rectangle-only layer Aliases to the list
        rect_layers_alias.append(layer.getAlias())

# Return the list of rectangle-only layers
return rect_layers_alias",Get the layers that are set as RectOnly and get their alias.
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Dictionary to store resistance of all layers
layer_resistance = {}

# Iterate through each layer to retrieve resistance
for layer in layers:
    layer_resistance[layer.getName()] = layer.getResistance()

# Dictionary to store edge capacitance of all layers
layer_edge_capacitance = {}

# Iterate through each layer to retrieve edge capacitance
for layer in layers:
    layer_edge_capacitance[layer.getName()] = layer.getEdgeCapacitance()

# Combine resistance and edge capacitance dictionaries into a single result dictionary
result = {
    ""edge_capacitance"": layer_edge_capacitance,
    ""layer_resistance"": layer_resistance
}

# Return the result dictionary
return result
",Get the resistance and edge capacitance of all the layers
"# Get the current block of the design
block = design.getBlock()

# Find the port named 'req_val'
port = block.findBTerm('req_val')

# Disconnect the port from the nets it is connected to
port.disconnect()

# Set the port named 'req_val' to special
port.setSpecial()

# Get the logic ports
logic_ports = block.getLogicPorts()

# Return the logic ports
return logic_ports","Disconnect the port named 'req_val' from the nets it is connected to and set the port named 'req_val' to special, and return the logic ports"
"# Get the current block of the design
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Get the wire_updated nets
updated_nets = block.getWireUpdatedNets(nets)

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# List to store horizontal layers in the technology file
horizontal_layers = []

# Iterate through each layer in the technology
for layer in layers:
    # Check if the layer direction is HORIZONTAL
    if layer.getDirection() == 'HORIZONTAL':
        # Append the horizontal layer to the list
        horizontal_layers.append(layer)

# Create a dictionary containing updated nets and horizontal layers
result = {
    ""nets"": updated_nets,
    ""layers"": horizontal_layers
}

# Return the result dictionary
return result",Get all the wire_updated nets and get the horizontal layers
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the count of layers
layer_count = tech.getLayerCount()

# Get the Routing Layer Count
routing_layer_count = tech.getRoutingLayerCount()

# Get the logic ports
logic_ports = block.getLogicPorts()

# Create a dictionary containing layer count, routing layer count, and logic ports
result = {
    ""layer_count"": layer_count,
    ""routing_layer_count"": routing_layer_count,
    ""logic_ports"": logic_ports
}

# Return the result dictionary
return result","Get the count of layers and get the routing layer count, along with the logic ports"
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the count of Manufacturing Grid
mfg = tech.getManufacturingGrid()

# Find the net with name ""req_msg[13]""
net = block.findNet(""req_msg[13]"")

# Set the Capacitance Coupling Adjust Order of the net to 1
net.setCcAdjustOrder(1)

# Return the count of Manufacturing Grid
return mfg","Get the count of manufacturing grid and set the capacitance Coupling Adjust Order of the net with name ""req_msg[13]"" to 1."
"# Get the current block of the design
block = design.getBlock()

# Find the net with name ""req_msg[11]""
net1 = block.findNet(""req_msg[11]"")
# Set the Capacitance Coupling Adjust Factor to 1
net1.setCcAdjustFactor(1)

# Find the net with name ""req_msg[12]""
net2 = block.findNet(""req_msg[12]"")
# Set the Capacitance Coupling Calibration Factor to 2
net2.setCcCalibFactor(2)","Set the Capacitance Coupling Adjust Factor of the net with name ""req_msg[11]"" to 1 and set the Capacitance Coupling Calib Factor of the net with name ""req_msg[12]"" to 2."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all nets present in the design block
nets = block.getNets()
result = []
# Iterate over each net in the design block
for net in nets:
        # Check the signal type of the net
        if net.getSigType() != 'POWER' and net.getSigType() != 'GROUND':
                # Get the name of the net
                net_name = net.getName()
                # Get the total Capacitance of the net
                net_cap = net.getTotalCapacitance()
                # Get the total resistance of the net
                net_res = net.getTotalResistance()
                # Get the total coupling capacitance of the net
                net_coupling = net.getTotalCouplingCap()
                # Append the net name, net capacitance, net resistance and net coupling
                result.append([net_name,net_cap,net_res,net_coupling])
return result","Get the total capacitance, total resistance, Coupling Capacitance of all the nets except the nets that are connected to Ground and Power External Power Supply. Get them as list of lists, in which each list contains the net name, net capacitance, net resistance and net coupling."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the pins (which are also called Iterms in OpenROAD)
pins = block.getITerms()
result = []
#Iterate through all the pins
for pin in pins:
        # Check if the pin is in clock
        if design.isInClock(pin.getInst()):
                # Append the pin to the result
                result.append(pin)
return result",Get all the Pins which are in clock net as a list.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""input1"" as mentioned in the prompt
inst = block.findInst(""input1"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the X Minimum of the Bounding Box of the instance
xmin = BBox.xMin()
# Get the Y Minimum of the Bounding Box of the instance
ymin = BBox.yMin()
# Get the X Maximum of the Bounding Box of the instance
xmax = BBox.xMax()
# Get the Y Maximum of the Bounding Box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Get the Bounding Box of an instance named ""input1"". Return a list of coordinates (Xmin, Ymin in one list and Xmax, Ymax in next list) "
"# Get all the libraries in the database
libs = db.getLibs()
d = {}
# Iterate through all the libraries files
for lib in libs:
        # Get the library cells of the library
        masterCells = lib.getMasters()
        cells = []
        # Iterate through all the library cells
        for master in masterCells:
                # Append the library cell to the cells
                cells.append(master)
        d[lib.getName()] = cells
return d",Get all the library cells as a dictionary of list. Key of the dictionary is library name and the value is the list of all the library cells in the library file 
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all nets present in the design block
nets = block.getNets()
result = []
# Iterate over each net in the design block
for net in nets:
        # Get the Pins of the net
        pins = net.getITerms()
        # Check if the length of number of pins of net is Zero
        if len(pins)==0:
                # Append the net to the result
                result.append(net)
return result",Get all the nets which are not connected to any pins and return them as list.
"# Get OpenDB
db = ord.get_db()
# Get all read libraries
libs = db.getLibs()
# Create a list to store the names
libcell_name_list = []
# Iterate through all libraries
for lib in libs:
	# Get all library cells in this library file
        lib_masters = lib.getMasters()
	# Iterate through all library cells
        for master in lib_masters:
		# Get the name of the library cell
                libcell_name = master.getName()
		# Add the name to the list
                libcell_name_list.append(libcell_name)
return libcell_name_list",Get the name of every liberty cell
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
orientation = []
# Retrieve all instances present in the design block
insts = block.getInsts()
# Iterate over each instance in the design block
for inst in insts:
        # Append the get rotation of the instance
        orientation.append([inst.getName(), inst.getOrient()])
return orientation",Get the rotations of all instances as a list of lists
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst('input1')
# Set the rotation of the instance as ""MX""
inst.setOrient('MX')",Set the rotation of an instance 'input1' as 'MX'
"# Get the current block from the design
block = design.getBlock()

# Retrieve the instance ""output53"" within the design
inst = block.findInst('output53')

# Initialize a list to store the net of the output pin
output_nets = []

pins = inst.getITerms()
        
# Iterate through each pin of the instance
for pin in pins:
    # Check if the pin represents as an output signal
    if pin.isOutputSignal():
        # Retrieve the net associated with this output pin
        net = pin.getNet()
        # If net is not None then append it to the output_net
        if net:
            output_nets.append(net)
        
# Return the net connected to the output pin of the specified instance
return output_nets",get the nets of the output pins of the instance 'output53'
"# Get the width and height of the bounding box of instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Get the Bounding Box
bounding_box = inst.getBBox()

# Get the DX and DY of the Bounding Box of the instance
return (bounding_box.getDX(), bounding_box.getDY())",Get the width and height of the bounding box of instance '_411_'
"# Set the level of all 'AND2_X1' gate instances in the design to 1

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through all instances
for inst in insts:
    # Check if the instance's master name contains 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Set the level of the instance to 1
        inst.setLevel(1, False)",set the level of all 'AND2_X1' gate instance in the design to 1
"# Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store the coordinates of the lower-left corner of the bounding box of the instances
inst_to_master_transform_offset = {}

# Iterate through all instances
for inst in insts:
    
    # Check if the name of the library cell type is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Add the instance name and the coordinates of the lower-left corner of the bounding box to the dictionary
        inst_to_master_transform_offset[inst.getName()] = inst.getTransform().getOffset()

# Return the dictionary containing the coordinates of the lower-left corner of the bounding box of the instances
return inst_to_master_transform_offset",Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'
"# Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store the coordinates of the lower-left corner of the bounding box of the instances
inst_to_master_transform_offset = {}

# Iterate through all instances
for inst in insts:
    
    # Check if the name of the library cell type is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Add the instance name and the coordinates of the lower-left corner of the bounding box to the dictionary
        inst_to_master_transform_offset[inst.getName()] = inst.getOrigin()

# Return the dictionary containing the coordinates of the lower-left corner of the bounding box of the instances
return inst_to_master_transform_offset",Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'
"# Retrieve the orientation of instances that have 'AND2_X1' as their library cell type.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store the orientation of instances
inst_to_master_transform_orient = {}

# Iterate through all instances
for inst in insts:
    # Check if the master name is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Add the instance name and its rotation to the dictionary
        inst_to_master_transform_orient[inst.getName()] = inst.getTransform().getOrient()

# Return the dictionary containing the orientation of instances
return inst_to_master_transform_orient",Retrieve the rotation of instances that have 'AND2_X1' as their library cell type.
"# Retrieve the orientation of instances that have 'AND2_X1' as their library cell type.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store the orientation of instances
inst_to_master_transform_orient = {}

# Iterate through all instances
for inst in insts:
    # Check if the master name is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Add the instance name and its rotation to the dictionary
        inst_to_master_transform_orient[inst.getName()] = inst.getOrient()

# Return the dictionary containing the orientation of instances
return inst_to_master_transform_orient",Retrieve the rotation of instances that have 'AND2_X1' as their library cell type.
"# Get the first output pin of an instance and map it to the instance names as the value in the dictionary.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store instances and their output pins
inst_outputs = {}

# Iterate through all instances
for inst in insts:
    # Add the instance name and its first output pin to the dictionary
    inst_outputs[inst.getName()] = inst.getFirstOutput()

# Return the dictionary containing instances and their output pins
return inst_outputs",Get the first output pin of an instance and map it to the instance names as the value in the dictionary.
"# Set the user-defined flags 1and 3 to true for instance '_411_' and return the instance

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Set the user-defined flags 1 and 3 to true
inst.setUserFlag1()
inst.setUserFlag3()

# Return the modified instance
return inst",Set the user-defined flags 1and 3 to true for instance '_411_' and return the instance
"# Get the ul, ll, lr, ur coordinates of the placement bounding box of the master cell of the instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the master cell associated with the instance
master = inst.getMaster()

# Get the placement bounding box of the master cell
placement_boundary = master.getPlacementBoundary()

# Get the coordinates of the placement bounding box

# Upper Left placement bounding box
ul = placement_boundary.ul()

# Lower Left Left placement bounding box
ll = placement_boundary.ll()

# Lower Right placement bounding box
lr = placement_boundary.lr()

# Upper Right placement bounding box
ur = placement_boundary.ur()

# Return the coordinates
coordinates = [ul, ur, lr, ll]
return coordinates","get the upper left, upper right, lower left, lower right coordinates of the placement bounding box of the master cell of the instance '_411_'"
"# Get the current block of the design
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Check if instance '_411_' is type ENDCAP or any of its subtypes
inst_is_endcap = inst.isEndCap()

# Clear user-defined flags of instance '_411_'
inst.clearUserFlag1()
inst.clearUserFlag2()
inst.clearUserFlag3()

# List to store instances having hierarchy and whose library cell name is ""AND2X_1"" and on level 1
inst_list = []

# Iterate through each instance
for inst in insts:
    # Check if the instance is hierarchical, its library cell name is ""AND2X_1"", and is level 1
    if inst.isHierarchical() and inst.getMaster().getName() == ""AND2X_1"" >= 0 and inst.getLevel() == 1:
        # Append the instance to the list
        inst_list.append(inst)

# Return a tuple containing the status of the instance '_411_' to determine if it is of type ENDCAP or any of its subtypes, along with a list of instances that have a hierarchy.
return (inst_is_endcap, inst_list)
","Check if the instance '_411_' is type ENDCAP or any of its subtypes, and clear user-defined flags of instance '_411_', then get all the instances with hierarchicy and whose library cell is AND2X_1 and the instance is level 1."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst('input1')
# Get the corresponding design block of the instance
return inst.getBlock()","Given the instance name 'input1', get the design block this instance belongs to."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the DB units per micron
return block.getDbUnitsPerMicron()",Convert 1 um to units used in this technology in OpenROAD
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the DEF units of this technology
return block.getDefUnits()",Get the DEF units of this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the db rows
rows = block.getRows()
d = {}
# Iterate through all the rows
for row in rows:
        # Get the name of the db row
        name = row.getName()
        # Get the spacing of the db row
        spacing = row.getSpacing()
        d[row] = [name, spacing]
return d","Get the rows with its name and spacing in a form of a dictionary. The key of the dictionary is the row object, the value is a list containing name and spacing of the row object"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the unit used in def file to 3000 as mentioned in the prompt
block.setDefUnits(3000)",Set the def units per micron to 3000
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the modules
modules = block.getModules()
module_names = []
# Iterate through all the modules
for module in modules:
        # Append the names of the module
        module_names.append(module.getName())
return module_names",Get all the modules and return the names of modules as a list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst(""inpu1"")
inst.setUserFlag1()","Set user-defined flag 1 to ture on the instance with name ""input1"""
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
adjust_factor = []
# Iterate through all the nets
for net in nets():
        # Append the capacitance coupling adjust factor of the net
        adjust_factor.append(net.getCcAdjustFactor())
return adjust_factor",Get the capacitance coupling Adjust Factor of every net and return them as a list.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
adjust_order = []
# Iterate throgh all the nets
for net in nets():
        # Append the capacitance coupling adjust order of the net
        adjust_order.append(net.getCcAdjustOrder())
return adjust_order",Get the capacitance coupling Adjust Order of every net and return them as a list.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
track_list = []
# Iterate throgh all the nets
for net in nets:
        # Get the tracks of the net
        tracks = net.getTracks()
        # Append the tracks to the track list
        track_list.append(tracks)
return track_list",Get the tracks of every net as a list of lists. Each list in the output list should contain the tracks of respective net
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst(""input1"")
# Get the nets of the instance
nets = inst.getNets()
track_list = []
# Iterate through all the nets
for net in nets:
        # Get the tracks of the net
        tracks = net.getTracks()
        track_list.append(tracks)
return track_list","Get the tracks of nets that are connected to instance with name ""input1"" as a list of list. Each list in the output list should contain the tracks of respective net"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the nets
nets = block.getNets()
types = []
# Iterate through all the nets
for net in nets:
        # Append the wire type of the net
        types.append(net.getWireType())
return types",Get the wire type of each net and return them as a list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the nets
nets = block.getNets()
termsCount = []
# Iterate through all the nets
for net in nets:
        # Get term counts of the net and append to the array
        termsCount.append(net.getTermCount())
return termsCount",Get term count of every net and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
insts = block.getInsts()
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rise arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than 0.5 second as mentioned in the prompt
                if pin_rise_arr > 0.5:
                        output.append(pin)
return output",Get all the pins which has the rising arrival time greater than 0.5 sec and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
insts = block.getInsts()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is less than or equal 0.5 second as mentioned in the prompt
                if pin_rise_arr <= 0.5:
                        output.append(pin)

return output",Get all the pins which has the rising arrival time less than or equal to 0.5 second and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
insts = block.getInsts()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the fall arrival time is greater than 0.8 second as mentioned in the prompt
                if pin_fall_arr > 0.8:
                        # Append the pin to the output
                        output.append(pin)

return output",Get all the pins which has Pin Fall Arrival Time greater than 0.8 sec and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
# Iterate through all the nets
for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
                return True
return False",Check all the nets and check if any of its wires is replaced with a new wire. Return True if Altered and false otherwise
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
# Iterate through all the ports
for port in ports:
        # Append the name and net of the port in the dictionary
        d[port.getName()] = port.getNet()
return d",Get all the net of ports and return a dictionay with port name as key and Net of the port as Value of the dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
# Iterate through all the ports
for port in ports:
        # Append the name and block pins objects of the port in the dictionary
        d[port.getName()] = port.getBPins()
return d",Get all the design block pins objects of ports and return a dictionay with port name as key and pins of the port as Value of the dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the design block ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
placement_status_with_name = {}
# Iterate through all the ports
for port in ports:
        # Get the name of the port
        name = port.getName()
        # Get the placement status of the port
        status = port.getFirstPinPlacementStatus()
        # Append the placement status and name of the port to the dictionary
        placement_status_with_name[name] = status
return placement_status_with_name",Get the name of every design block port with the placement status of the first pin as a dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
output = []
# Iterate through all the ports
for port in ports:
        # Append the port name and signal type of the port to the dictionary
        d[port.getName()] = port.getSigType()
return d",Get the name of every block port with its signal type as a dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
output = []
# Iterate through all the ports
for port in ports:
        # Append the port name and IO type of the port to the dictionary
        d[port.getName()] = port.getIoType()
return d",Get all the I/O types of ports and return a dictionay with port name as keys and IO Type of the port as values
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm(""req_val"")
# Find the boundary box of the port
BBox = port.getBBox()
# Get the X Min of the bounding box
xmin = BBox.xMin()
# Get the Y Min of the bounding box
ymin = BBox.yMin()
# Get the X Max of the bounding box
xmax = BBox.xMax()
# Get the Y Max of the bounding box
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Get the Bounding Box of a port named ""req_val"". Return a list of coordinates (Xmin, Ymin in one list and Xmax, Ymax in another list) "
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm('req_val')
# Set SPECIAL attribute to the port
port.setSpecial()",Set SPECIAL attribute port named 'req_val'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm('req_val')
# Return whether the port has SPECIAL
return port.isSpecial()",Check if the port named 'req_val' has SPECIAL attribute
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
# get and report wire_updated nets
return block.getWireUpdatedNets(nets)",Get the of nets for any wire changes and report the statistics of the nets with changed wires.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the technology layers
return tech.getLayers()",Get the technolgy layers. The layers are ordered from the bottom mask number to the top mask number.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the number of layers in this technology.
return tech.getLayerCount()",Get the number of layers in this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the number of routing-layers in this technology.
return tech.getRoutingLayerCount()",Get the number of routing-layers in this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the number of vias in this technolgy.
return tech.getViaCount()",Get the number of vias in this technolgy.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the via generate rules in this technolgy
return tech.getViaGenerateRules()",Get the via generate rules in this technolgy.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get the technolgy vias. This includes non-default-rule-vias.
return tech.getVias()",Get the technolgy vias
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get LEF CLEARANCEMEASURE
return tech.getClearanceMeasure()",Get LEF CLEARANCEMEASURE
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return MANUFACTURINGGRID
# NOTE: Assumes conversion to internal DB units,
# NOT microns or LEF/DEF units
return tech.getManufacturingGrid()",Get MANUFACTURINGGRID
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the net with name ""req_msg[11]""
net = block.findNet(""req_msg[11]"")
# Set the capacitance coupling adjust factor of the net to 1
net.setCcAdjustFactor(1)","Set the capacitance coupling adjust factor of the net with name ""req_msg[11]"" to 1"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the net with name ""req_msg[11]""
net = block.findNet(""req_msg[11]"")
# Set the capacitance coupling calibration factor of the net to 2
net.setCcCalibFactor(2)","Set the capacitance coupling calibration factor of the net with name ""req_msg[11]"" to 2"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
output = {}
# Iterate through all the nets
for net in nets:
        # Append the net name and capacitance coupling match ratio against the net to a dictionary
        output[net.getName()] = net.getCcMatchRatio()
return output",Get the capacitance coupling match ratio against this nets with the name of the net. Return a dictionary with key being the name of the net and value of the dictionary is the capacitance coupling match ratio against the net
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Iterate through the net names ""req_msg[13] and ""clk"" as mentioned in the prompt
for net_name in [""req_msg[13]"", ""clk""]:
        # Find the net with net name as parameter
        net = block.findNet(net_name)
        # Set the coupling capacitance match ratio against the net to 1
        net.setCcMatchRatio(1)","Set the coupling capacitance match ratio against the net with name ""req_msg[13]"" and ""clk""  to 1"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get the technology layers
layers = tech.getLayers()
output = []
# Iterate through all the layers
for layer in layers:
        # Get the names of the technology layers
        output.append(layer.getName())
return output",Get the names of the technology layers
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get all the tehnology layers
layers = tech.getLayers()
output = {}
# Iterate through all the technology layers
for layer in layers:
        # Append the layer name and AREA parameter to the dictionary
        output[layer.getName()] = layer.getArea()
return output",Get the AREA parameter of the technology layers with their name. Return a dictionary with key as the layer name and value as the AREA parameter 
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get all the technology layers
layers = tech.getLayers()
output = {}
# Iterate through all the layers
for layer in layers:
        # Append the layer name and layer direction to the dictionary
        output[layer.getName()] = layer.getDirection()
return output",Get the directions of the technology layers with their name. Return a dictionary with key as the layer name and value as the layer direction 
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name 'metal8'
layer = tech.findLayer('metal8')
# Return the routing layer corner spacing rule
return layer.getTechLayerCornerSpacingRules()",Get the routing layer corner spacing rules of technology layer with name 'metal8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name 'metal8'
layer = tech.findLayer('metal8')
# Return the cut layer class rule
return layer.getTechLayerCutClassRules()",Get the cut layer class rule of layer with name 'metal8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name 'metal8'
layer = tech.findLayer('metal8')
# Get the cut layer spacing rules
return layer.getTechLayerCutSpacingRules()",Get the cut layer spacing rules of layer with name 'metal8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal10"" 
layer = tech.findLayer('metal10')
# Return the end of line extension rules
return layer.getTechLayerEolExtensionRules()",Get the end of line extension rules of the technology layer with name 'metal10'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology object with technology information
tech = block.getTech()
# Find the layer with name ""via8"" 
layer = tech.findLayer('via8')
# Return the tech layer forbidden spacing rules
return layer.getTechLayerForbiddenSpacingRules()",Get the forbidden spacing rules of the technology layer with name 'via8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""via1"" 
layer = tech.findLayer('via1')
# Return the keepout zone rules
return layer.getTechLayerKeepOutZoneRules()",Get the keepout zone rules of the technology layer with name 'via1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer called ""OVERLAP"" 
layer = tech.findLayer('OVERLAP')
# Return two widths spacing rules
# API for version 5.7 two widths spacing rules, expressed as a 2D matrix
# with index tables
return layer.getTwoWidthsSpacingTableNumWidths()",Get the two widths spacing rules of the technology layer with name 'OVERLAP'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name ""metal1"" 
layer = tech.findLayer('metal1')
# Return the min cut rules
return layer.getTechLayerMinCutRules()",Get the minimum cut rules of the technology layer with name 'metal1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name ""via2"" 
layer = tech.findLayer('via2')
# Return the  minimum step rules
return layer.getTechLayerMinStepRules()",Get the minimum step rules of the technology layer with name 'via2'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the collection of spacing rules for the object, assuming
# coding in LEF 5.4 format.
return layer.getV54SpacingRules()",Get the collection of spacing rules for the layer with name 'metal3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal4""
layer = tech.findLayer('metal4')
# Return the spacing end of line rules
return layer.getTechLayerSpacingEolRules()",Get the spacing end of line rules of layer with name 'metal4'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal5""
layer = tech.findLayer('metal5')
# Return the layer type
return layer.getType()",Get the type of technology layer with name 'metal5'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""via3""
layer = tech.findLayer('via3')
# Return the wrong direction spacing rules
return layer.getTechLayerWrongDirSpacingRules()",Get the wrong direction spacing rules of layer with name 'via3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal1""
layer = tech.findLayer('metal1')
# Return the x-axis offset
return layer.getOffset()",Get the offset along the x-axis of the technology layer with name 'metal1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal2""
layer = tech.findLayer('metal2')
# Return the x-axis offset
return layer.getOffsetX()",Get the offset along the x-axis of the technology layer with name 'metal2'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the y-axis offset
return layer.getOffsetY()",Get the offset along the y-axis of the technology layer with name 'metal3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the y-axis offset
layer.setOffsetXY(0.2, 0.15)",Change the offset setting along the x-axis to 0.2 microns and the y-axis to 0.15 microns for the technology layer named 'metal3'.
"# Retrieve block information
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Get the technology information
tech = block.getTech()

# Initialize a dictionary to store instance halos
inst_halos = {}

# Iterate through each instance
for inst in insts:
    # Store the halo information for each instance
    inst_halos[inst.getName()] = inst.getHalo()

# Find layer information for 'metal4'
layer1 = tech.findLayer('metal4')

# Get technology layer spacing End-of-Line (EOL) rules for 'metal4'
layer_spacing_eol_rules = layer1.getTechLayerSpacingEolRules()

# Find layer information for 'metal8'
layer2 = tech.findLayer('metal8')

# Get technology layer corner spacing rules for 'metal8'
layer2_corner_spacing_rules = layer2.getTechLayerCornerSpacingRules()

# Find layer information for 'metal5'
layer3 = tech.findLayer('metal5')

# Get technology layer cut class rules for 'metal5'
layer_cut_class_rules = layer3.getTechLayerCutClassRules()

# Store all the collected information in a dictionary
result = {
    ""halos"": inst_halos,
    ""metal4_EOL"": layer_spacing_eol_rules,
    ""metal8_corner_spacing_rules"": layer2_corner_spacing_rules,
    ""cut_class_rules"": layer_cut_class_rules
}

# Return the collected information
return result","Get the following in a dictionary, with the given key names:
1. get all the halos of the instances with inst name as key. the key should be halos.
2. Get the routing layers spacing EOL rules of layer with name 'metal4'. The key should be metal4_EOL.
3. Get the routing layers corner spacing rules of layer with name 'metal8'. The key should be metal8_corner_spacing_rules.
4. get the routing layers cut class rules of layer with name 'metal8'. The key name for this will be cut_class_rules."
"# Get the current design block
block = design.getBlock()

# Retrieve the capacitor-coupled segments
cc_segments = block.getCCSegs()

# Get all instances
insts = block.getInsts()

# Dictionary to store source type of instances on level 1 whose master cells are either NAND or NOR
src_type = {}

# Iterate through each instance
for inst in insts:
    # Get the library cell of the instance
    master = inst.getMaster()
    
    # Check if the library cell is special power type
    if master.isSpecialPower():
        # Set the master of the instance as frozen so dbMTerms cannot be added or delete from the master once it is frozen.
        inst.getMaster().setFrozen(True)
    
    # Check if the name of library cell is ""NAND2_X1"" or ""NOR3_X1"" and the instance is on level 1
    if (master.getName() == ""NAND2_X1"" or master.getName() == ""NOR3_X1"") and inst.getLevel() == 1:
        # Store the source type of the instance in the dictionary
        src_type[inst.getName()] = inst.getSourceType()

# Return the tuple containing the cc_segments and the source type dictionary of instances
return (cc_segments, src_type)","Retrieve the capacitor-coupled segments and frozen the library cells with special power type, then get source type of all the instances on level 1 whose master cells are either ""NAND2_X1"" or ""NOR3_X1""."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Find the instance '_411_'
inst1 = block.findInst('_411_')

# Set user-defined flags 1 and 3 for instance '_411_'
inst1.setUserFlag1()
inst1.setUserFlag3()

# Find the instance 'input1'
inst2 = block.findInst('input1')

# Mark the first output nets of the instances '_411_' and 'input1'
net1 = inst1.getFirstOutput().getNet()

# Dictionary to store instance transform offsets
inst_transform_offset_dict = {}

# Iterate through each instance
for inst in insts:
    # Check if the master cell name is ""AND2X_1""
    if inst.getMaster().getName() == ""AND2X_1"":
        # Store the offset of the instance with master 'AND2_X1'
        inst_transform_offset_dict[inst.getName()] = inst.getTransform().getOffset()

# Return the dictionary containing instance transform offsets
return inst_transform_offset_dict","Set user-defined flags 1 and 3 for instance '_411_' and mark the first output nets of the instances '_411_' and 'input1', followed by getting the offset of the instances whose master is 'AND2_X1' in the form of dictionary with instance name as key."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store instances and their respective regions
inst_regions = {}

# List to store pad instances on level 0
inst_list = []

# Iterate through each instance
for inst in insts:
    # Store instance name and its region in the inst_regions dictionary
    inst_regions[inst.getName()] = inst.getRegion()
    
    # Check if the instance is a pad and it's on level 0
    if inst.isPad() and inst.getLevel() == 0:
        # Append the instance to the list of pad instances
        inst_list.append(inst)
    
    # Check if the instance name is ""input1""
    if inst.getName() == ""input1"":
        # Iterate through each pin of the instance
        for pin in inst.getITerms():
            # Get the net connected to the pin
            net = pin.getNet()
            # Check if the net exists
            if net:
                # Set RC disconnected for the net
                net.setRCDisconnected(True)

# Return the list of pad instances
return inst_list",Retrieve the instances and their corresponding areas if they are PAD or any of its subtypes and set as level 0. Proceed to disconnect the RC for the networks associated with the 'input1' instance.
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store offsets of instances whose master cell is 'NAND2_X1'
NAND_offsets = {}

# Iterate through each instance
for inst in insts:
    # Check if the library cell name is ""NAND2_X1""
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Store the xy location of the instance
        NAND_offsets[inst.getName()] = inst.getTransform().getOffset()
    
    # Check if the instance name is ""_411_""
    if inst.getName() == ""_411_"":
        # Iterate through each pin of the instance
        for pin in inst.getITerms():
            # Get the net connected to the pin
            net = pin.getNet()
            # Check if the net exists
            if net:
                # Set RC disconnected for the net
                net.setRCDisconnected(True)

# Return the dictionary containing offsets of instances
return NAND_offsets",Get the offset of all 'NAND2_X1' cells and set the RC disconnected for the nets of the instance 'input1'.
"block = design.getBlock()

# find the instance 'output53'
inst = block.findInst('output53')

# Initialize a list to store the input pins of the instance
input_pins = []


# Obtain all pins associated with this instance
pins = inst.getITerms()
        
# Iterate through each pin of the instance
for pin in pins:
    # Check if the pin represents an input signal
    if pin.isInputSignal() and pin:
        # Append the input pin to the list of input pins
        input_pins.append(pin)

# Return the list of input pins connected to the instance
return input_pins",get the input pins of the instance 'output53'
"# Get the nets of the input pins of instance 'output53'

block = design.getBlock()

# find the instance 'output53'
inst = block.findInst('output53')

# Initialize a list to store nets of input pins
input_nets = []

# Get all input pins (ITerms) of the instance
pins = inst.getITerms()

# Iterate through all input pins
for pin in pins:
    # Check if the pin is an input signal
    if pin.isInputSignal() and pin:
        # If it's an input signal, add its net to the list
        input_nets.append(pin.getNet())

# Return the list of nets of input pins of the instance
return input_nets",get the nets connected to the input pins of the instance 'output53'
"# Retrieve all instances that have a hierarchy and whose library cell type is 'AND2_X1' and are on level 1.

block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store matching instances
inst_list = []

# Iterate through all instances
for inst in insts:
    # Check if the instance has hierarchy, its library cell is 'AND2_X1', and it is on level 1
    if inst.isHierarchical() and inst.getMaster().getName()==""AND2_X1"" and inst.getLevel() == 1:
        # Add the instance to the list
        inst_list.append(inst)

# Return the list of matching instances
return inst_list
",Retrieve all instances that have a hierarchy and whose library cell type is 'AND2_X1' and are on level 1.
"# Get the resistor segments

# Get the design block
block = design.getBlock()

# Return the resistor segments
return block.getRSegs()",get the resistor segments of the design block
"# Retrieve the LEQ (Logical equivalent) information associated with the library cell of instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the library cell associated with the instance
master = inst.getMaster()

# Retrieve the LEQ information
leq_info = master.getLEQ()

# Return the LEQ information
return leq_info",Retrieves the LEQ (Logical equivalent) information associated with the library cell of instance '_411_'
"# Get all the pad and set as level 1

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store matching instances
inst_list = []

# Iterate through all instances
for inst in insts:
    # Check if the instance is a pad and it is level 1
    if inst.isPad() and inst.getLevel() == 1:
        # Add the instance to the list
        inst_list.append(inst)

# Return the list of matching instances
return inst_list",get all the pad instances that are level 1 
"# Get the vertical thickness multiplier for the IO pin placer's parameters and set corner avoidance to 50

# Get the IO pin placer
iop = design.getIOPlacer()

# Get the parameters of the IO pin placer
parameters = iop.getParameters()

# Set corner avoidance to 50
parameters.setCornerAvoidance(50)

# Return the vertical thickness multiplier
return parameters.getVerticalThicknessMultiplier()",get the vertical thickness multiplier for the IO pin placer's parameters and set corner avoidance to 50
"# Get the design block
block = design.getBlock()

# Find the instance named ""FILLER_0_17_159""
inst = block.findInst(""FILLER_0_17_159"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Reverse the resistor segment sequence of the net
        net.reverseRSegs()
",Reverse the resistor segment seqence of the nets of the instance FILLER_0_17_159
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets with wire-ordered flag set as True
ordered_wires = []

# Iterate through each net
for net in nets:
    # Check if the wire-ordered flag is set to true
    if net.isWireOrdered():
        # Append the net to the list
        ordered_wires.append(net)

# Return the list of nets with ordered wires
return ordered_wires
","Get the nets if their wire-ordered flag is set as True, and return it as a list"
"# Get the design block
block = design.getBlock()

# List of net names to set wire type as ROUTED
nets = [
    ""_000_"",
    ""_001_"",
    ""_002_"",
    ""_003_"",
    ""_004_"",
    ""_005_"",
    ""_006_"",
    ""_007_"",
    ""_008_"",
    ""_009_"",
    ""_010_""
]

# Iterate through each net name
for name in nets:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the wire type of the net as ROUTED
    net.setWireType('ROUTED')


","Set the following nets wire type to ROUTED: _000_, _001_, _002_, _003_, _004_, _005_, _006_, _007_, _008_, _009_, _010_
"
"# Get the design block
block = design.getBlock()

# List to store nets with ordered wires
ordered_wires = []

# List of net names
nets = [
    ""net1"",
    ""net10"",
    ""net11"",
    ""net12"",
    ""net13"",
    ""net14"",
    ""net15"",
    ""net16"",
    ""net17"",
    ""net18"",
    ""net19""
]

# Iterate through each net name
for name in nets:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the wire ordered flag to true
    net.setWireOrdered(True)
    
    # Append the net to the list of nets with ordered wires
    ordered_wires.append(net)

# Return the list of nets with ordered wires
return ordered_wires
","Set the wires ordered flag to true for the following nets and return a list of these nets: net1, net10, net11, net12, net13, net14, net15, net16, net17, net18, net19
"
"# Get the design block
block = design.getBlock()

# List to store nets 
altered_wires_net = []

# List of net names
nets = [
    ""_000_"",
    ""_001_"",
    ""_002_"",
    ""_003_"",
    ""_004_"",
    ""_005_"",
    ""_006_"",
    ""_007_"",
    ""_008_"",
    ""_009_"",
    ""_010_""
]

# Iterate through each net name
for name in nets:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the wire update flag to true
    net.setWireAltered(True)
    
    # Append the net to the list of nets
    altered_wires_net.append(net)

# Return the list of the nets
return altered_wires_net
","Set the wire update flag to true for the wires of the following nets and return a list of these nets: _000_, _001_, _002_, _003_, _004_, _005_, _006_, _007_, _008_, _009_, _010_
"
"# Get the design block
block = design.getBlock()

# List to store selected nets
selected_nets = []

# List of net names to select
net_names = [
    ""net1"",
    ""net10"",
    ""net11"",
    ""net12"",
    ""net13"",
    ""net14"",
    ""net15"",
    ""net16"",
    ""net17"",
    ""net18"",
    ""net19""
]

# Iterate through each net name
for name in net_names:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the net as selected
    net.setSelect(True)
    
    # Append the selected net to the list
    selected_nets.append(net)

# Return the list of selected nets
return selected_nets
","set the select flag true for the following nets and return the list of these nets: net1, net10, net11, net12, net13, net14, net15, net16, net17, net18, net19
"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets
wild_connected_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is connected using a wild-card
    if net.isWildConnected():
        # Append the net to the list
        wild_connected_nets.append(net)

# Return the list of nets
return wild_connected_nets
",Get the nets connected using a wild-card.
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets marked as ""do not touch""
do_not_touch_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is set as ""do not touch""
    if net.isDoNotTouch():
        # Append the net to the list
        do_not_touch_nets.append(net)

# Return the list of nets set as ""do not touch""
return do_not_touch_nets",Get the nets that are set as do not touch and return as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective coupled capacitor adjust orders
net_Cc_adjust_order = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its coupled capacitor adjust order in the dictionary
        net_Cc_adjust_order[net.getName()] = net.getCcAdjustOrder()

# Return the dictionary containing net names and their Cc adjust orders
return net_Cc_adjust_order",Get the coupled capacitor adjust order for the nets of the instance input6 and return the result as a dict with key being net name and value being the coupled capacitor adjust order
"# Get the design block 
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective wire types
net_wire_type = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its wire type in the dictionary
        net_wire_type[net.getName()] = net.getWireType()

# Return the dictionary containing net names and their wire types
return net_wire_type",Get the wire types of the nets connecting to the instance input6 and return the result as a dictionary with key being net name and value being the wire type
"# Get the design block
block = design.getBlock()

# List to store marked nets
marked_nets = []

# List of net names to mark
nets_to_mark = [
    ""resp_msg[4]"",
    ""resp_msg[5]"",
    ""resp_msg[6]"",
    ""resp_msg[7]"",
    ""resp_msg[8]"",
    ""resp_msg[9]"",
    ""resp_rdy"",
    ""resp_val""
]

# Iterate through each net name
for name in nets_to_mark:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the mark flag of the net to True
    net.setMark(True)
    
    # Append the marked net to the list
    marked_nets.append(net)

# Return the list of marked nets
return marked_nets","Set mark flags to the nets resp_msg[4], resp_msg[5], resp_msg[6], resp_msg[7], resp_msg[8], resp_msg[9], resp_rdy, resp_val and return the list of market nets."
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store selected nets
selected_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is selected
    if net.isSelect():
        # Append the net to the list
        selected_nets.append(net)

# Return the list of selected nets
return selected_nets",Get the selected nets
"# Get thedesign block
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective total resistances
net_total_resistance = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its total resistance in mil ohms in the dictionary
        net_total_resistance[net.getName()] = net.getTotalResistance()

# Return the dictionary containing net names and their total resistances
return net_total_resistance
","Get the total resistance in mil ohms of the nets connecting to the instance ""input6"" and return the result as a dict using net name as key and resistance as value"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets connected by abutment
abutment_nets = []

# Iterate through each net
for net in nets:
    # Check if the net have its pins connected by abutment
    if net.isConnectedByAbutment():
        # Append the net to the list
        abutment_nets.append(net)

# Return the list of nets connected by abutment
return abutment_nets",Get the nets that have their pins connected by abutment and return as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""_699_""
inst = block.findInst(""_699_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective coupled capacitor match ratio
net_cc_match_ratio = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its coupled capacitor match ratio in the dictionary
        net_cc_match_ratio[net.getName()] = net.getCcMatchRatio()

# Return the dictionary containing net names and their Cc Match ratios
return net_cc_match_ratio
","Get the coupled capacitor match ratio of the nets connecting to the instance ""_699_"" and return as a dict using net name as key and coupled capacitor match ratio as value"
"# Get the design block
block = design.getBlock()

# Find the instance named ""input10""
inst = block.findInst(""input10"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective node capacitors
net_cap_nodes = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its cap nodes in the dictionary
        net_cap_nodes[net.getName()] = net.getCapNodes()

# Return the dictionary containing net names and their cap nodes
return net_cap_nodes","Get the node capacitor of the RC segment belong to each net connecting to the instance input10, and return the result as a dict with net name being keys and node capacitors as values"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal4""
layer = tech.findLayer('metal4')
# Return the pitch of the layer
return layer.getPitch()","Get the pitch setting of ""metal 4"" layer"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store extracted nets
extracted_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is extracted
    if net.isExtracted():
        # Append the extracted net to the list
        extracted_nets.append(net)

# Return the list of extracted nets
return extracted_nets",Get all extracted nets as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""input10""
inst = block.findInst(""input10"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective routing guides
net_guides = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its routing guides in the dictionary
        net_guides[net.getName()] = net.getGuides()

# Return the dictionary containing net names and their routing guides
return net_guides","Get the routing guides of the nets connecting to the instance ""input10"" as a dictionary, using net name as keys and routing guide as values"
"# Get the design block
block = design.getBlock()

# Find the instance named ""FILLER_0_17_13""
inst = block.findInst(""FILLER_0_17_13"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective tracks
net_tracks = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its tracks in the dictionary
        net_tracks[net.getName()] = net.getTracks()

# Return the dictionary containing net names and their tracks
return net_tracks","Get the tracks of the nets connecting to the instance ""FILLER_0_17_13"", and return it as a dict using net name as keys and tracks as values"
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer29""
inst = block.findInst(""rebuffer29"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Reverse the coupled capacitor segments of the net
        net.reverseCCSegs()",Reverse the coupled capacitor segments of the nets connecting to the instance called rebuffer29
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer9""
inst = block.findInst(""rebuffer9"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective driving ITerms
net_driving_iterm = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its driving term id assigned of this net. -1 if not set, 0 if non existent
        net_driving_iterm[net.getName()] = net.getDrivingITerm()

# Return the dictionary containing net names and their driving ITerms
return net_driving_iterm","Get the driving term ids for the nets connecting to the instance rebuffer9, and return the rsult as a dict using net name as keys and driving term ids as values"
"# Get the design block 
block = design.getBlock()

# Find the instance named ""output52""
inst = block.findInst(""output52"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Print the net name
        print(""Net:"", net.getName())
        
        # Print the wire opcodes
        net.printWire()",Print the wire opcode information of the the nets connecting to the instance output52
"# Get the design block
block = design.getBlock()

# Find the instance named ""_706_""
inst = block.findInst(""_706_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective Cap node counts
net_cap_node_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its node capacitor count in the dictionary
        net_cap_node_count[net.getName()] = net.getCapNodeCount()

# Return the dictionary containing net names and their Cap node counts
return net_cap_node_count
","Get the node capacitor count of RC segments of the nets connecting to the instance _706_, and return the result as a dictionary with keys being net name, and values being node capacitor count  "
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets that are RC graphs
rc_graph_nets = []

# Iterate through each net
for net in nets:
    # Check if the rc_graph flag set, and the flag is set when Rseg and CapNodes were created
    if net.isRCgraph():
        # Append the net to the list 
        rc_graph_nets.append(net)

# Return the list of nets that are RC graphs
return rc_graph_nets
","Get all the nets if their rc_graph flag is set, and return the result as a list"
"# Get the design block
block = design.getBlock()

# Find the instance named ""split30""
inst = block.findInst(""split30"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective term counts
net_term_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and the amount of pins and ports of this net in the dictionary
        net_term_count[net.getName()] = net.getTermCount()

# Return the dictionary containing net names and their amount of pins and ports
return net_term_count","Get the amount of pins and ports of the nets connecting to the instance ""split30"" and return it as a dictionary with net name being keys"
"# Get the design block
block = design.getBlock()

# Find the instance named ""clkbuf_0_clknet_2_3__leaf_clk""
inst = block.findInst(""clkbuf_0_clknet_2_3__leaf_clk"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective x-talk classes
net_X_Talk_class = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its x-talk class in the dictionary
        net_X_Talk_class[net.getName()] = net.getXTalkClass() 

# Return the dictionary containing net names and their x-talk classes
return net_X_Talk_class","Get the x-talk-class of the nets connecting to the instance ""clkbuf_0_clknet_2_3__leaf_clk"", as a dictionary with the net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer5""
inst = block.findInst(""rebuffer5"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective first BTerms
net_first_bterms = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its first BTerm in the dictionary
        net_first_bterms[net.getName()] = net.get1stBTerm()

# Return the dictionary containing net names and their first BTerms
return net_first_bterms","Get the first port of the nets connecting to the instance rebuffer5, as a dictionary with the net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""input22""
inst = block.findInst(""input22"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective R segment counts
net_R_seg_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its R segment count in the dictionary
        net_R_seg_count[net.getName()] = net.getRSegCount()

# Return the dictionary containing net names and their R segment counts
return net_R_seg_count","Get the R segment count of the RC network connected to the nets of the instance input22, return the result as a dictionary with net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""_686_""
inst = block.findInst(""_686_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective nondefault rule applied for wiring
net_non_default_rule = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and the nondefault rule applied to this net for wiring in the dictionary, returns nullptr if there is no nondefault rule.
        net_non_default_rule[net.getName()] = net.getNonDefaultRule()

# Return the dictionary containing net names and their nondefault rule applied to this net for wiring
return net_non_default_rule",Get the nondefault rule applied to the nets connected to the instance _686_ as a dictionary with the net names as key values.
"# Get the design block
block = design.getBlock()

# Find the instance named ""_706_""
inst = block.findInst(""_706_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective zeroth R segments
net_zero_R_segment = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its zeroth R segment in the dictionary
        net_zero_R_segment[net.getName()] = net.getZeroRSeg()

# Return the dictionary containing net names and their zeroth R segments
return net_zero_R_segment",Get the zeroth R segment of the nets of the instance _706_ as a dictionary with the net names as key values.
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Dictionary to store layer directions with their names
layer_direction_dict = {}

# Dictionary to store upper and lower layers of the 'poly' layer
poly_upper_lower_layers = {}

# Iterate through each layer
for layer in layers:
    # Store the direction of the layer with its name in the dictionary
    layer_direction_dict[layer.getName()] = layer.getDirection()
    
    # If the layer name is 'poly', store its upper and lower layers
    if layer.getName() == ""poly"":
        poly_upper_lower_layers = {
            ""upper"": layer.getUpperLayer(),
            ""lower"": layer.getLowerLayer()
        }

# Create a result dictionary containing layer directions and 'poly' upper and lower layers
result = {
    ""layer_directions"": layer_direction_dict,
    ""poly"": poly_upper_lower_layers
}

# Return the result dictionary
return result","Get the routing directions of the layers with their names as keys and also get the layers above and below the layer with name 'poly'. Finally, return them as dict of dicts"
"# Get the current design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Dictionary to store Capacitance Coupling Match Ratio of each net
net_cc_match_ratio = {}

# Iterate through each net and store its Capacitance Coupling Match Ratio
for net in nets:
    net_cc_match_ratio[net.getName()] = net.getCcMatchRatio()

# List of net names to set Capacitance Coupling Match Ratio to 1
nets = [""req_msg[13]"", ""clk""]

# Iterate through each net name in the list and set its Capacitance Coupling Match Ratio to 1
for net_name in nets:
    net = block.findNet(net_name)
    net.setCcMatchRatio(1)

# Return the dictionary containing Capacitance Coupling Match Ratio of each net
return net_cc_match_ratio
","Calculate the Capacitance Coupling Match Ratio for each net and organize the results into a dictionary. Use the net names as keys and their corresponding Capacitance Coupling Match Ratios as values. Additionally, ensure that the Capacitance Coupling Match Ratios for the nets named ""req_msg[13]"" and ""clk"" are set to 1."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the vias defined in the technology
vias = tech.getVias()

# Get the Via Count of the technology
via_count = tech.getViaCount()

# Set the Clearance Measure of the technology to 500
print(tech.getClearanceMeasure())

# Create a dictionary containing vias and the count of vias
result = {
    ""vias"": vias,
    ""count"": via_count
}

# Return the result dictionary
return result","Get the vias and via count as a dictionary with ""vias"" and ""count"" as keys, and print the Clearance Measure."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology file
layers = tech.getLayers()

# Dictionary to store areas of layers with their names
layer_area_dict = {}

# Iterate through each layer
for layer in layers:
    # Store the area of the layer with its name in the dictionary
    layer_area_dict[layer.getName()] = layer.getArea()

# Create a result dictionary containing layer area dictionary and list of layer names
result = {
    ""area_dict"": layer_area_dict,
    ""layer_names"": list(layer_area_dict.keys())
}

# Return the result dictionary
return result","Retrieve the layer names defined in the technology as a list and obtain the corresponding areas of these layers of the technology, associating each area with its respective layer name in a dictionary. Return this result encapsulated in a dictionary with ""area_dict"" representing the areas of the layers and ""layer_names"" representing the list of layer names."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the Via Count of the technology
via_count = tech.getViaCount()

# Get the Via Generate Rules of the technology
via_rules = tech.getViaGenerateRules()

# Get the current value of database units per micron and add 500
db_microns = block.getDbUnitsPerMicron() + 500

# Set the new value of database units per micron
tech.setDbUnitsPerMicron(db_microns)

# Create a dictionary containing via count, via rules, and the updated value of database units per micron
result = {
    ""count"": via_count,
    ""rules"": via_rules
}

# Return the result dictionary
return result","Retrieve the via count and via generate rules of the technology. Return the result as a dictionary with ""count"" and ""rules"" as keys for the via count and via generate rules, respectively."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store rotation of the instances whose library cells are of type 'NOR2_X1'
NOR_transform_orient = {}

# Iterate through each instance
for inst in insts:
    # Check if the library cell name is ""NOR2_X1""
    if inst.getMaster().getName() == ""NOR2_X1"":
        # Store the rotation of the instance
        NOR_transform_orient[inst.getName()] = inst.getTransform().getOrient()
    
    # Check if the instance name is ""_411_"" or ""input1""
    if inst.getName() == ""_411_"" or inst.getName() == ""input1"":
        # Mark the first output net of the instance
        inst.getFirstOutput().getNet().setMark(True)

# Return the dictionary containing orientation of instance
return NOR_transform_orient","Get the rotation of the instances whose library cells are of type 'NOR2_X1' and return as a dict with instance name as keys, and mark the first output nets of the instances '_411_' and 'input1'."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through each instance
for inst in insts:
    # Check if the master cell name contains ""NAND2_X1""
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Invert the instance
        inst.getTransform().invert()
    
    # Check if the instance name is ""_411_"" or ""input1""
    if inst.getName() == ""_411_"" or inst.getName() == ""input1"":
        # Get the transform of the instance
        transform = inst.getTransform()
        # If the orientation is 'R0', set it to 'MX'; if 'MX', set it to 'R0'
        if transform.getOrient() == 'R0':
            transform.setOrient('MX')
        elif transform.getOrient() == 'MX':
            transform.setOrient('R0')",Invert the offset and the rotation of instances whose library cells are 'NAND2_X1' and set the orient of the instance '_411_' to 'R0' if 'MX' or 'MX' if 'R0'.
"# Get the current design block
block = design.getBlock()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Set the orientation of the instance '_411_' to 'MX'
inst.getTransform().setOrient('MX')

# Get all instances
insts = block.getInsts()

# Dictionary to store halos of instances
inst_halos = {}

# Iterate through each instance
for inst in insts:
    # Store the halo of the instance in the inst_halos dictionary
    inst_halos[inst.getName()] = inst.getHalo()

# Return the dictionary containing halos of instances
return inst_halos",Set the orientation of the instance '_411_' to 'MX' and retrieve all the halos of instances. Return the result as a dictionary with each instance's name as the key mapped to their halo.
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Initialize lists to store non-core instances and vertical tech layers with capacitance
vertical_layers = []
non_core_insts = []

# Define the direction for the layers
direction = 'VERTICAL'

# Iterate through each instance
for inst in insts:
    # Check if instance is not core instance
    if not inst.getMaster().isCore():
        # Add the instance to the list of non-core instances
        non_core_insts.append(inst)

# Iterate through each layer in the technology
for layer in layers:
    # Check if the layer direction is VERTICAL
    if layer.getDirection() == direction:
        # Add the layer and its capacitance to the list of vertical layers
        vertical_layers.append((layer, layer.getCapacitance()))

# Return the list of non-core instances and horizontal layers with their capacitance
return (non_core_insts, horizontal_layers)",Get a list of all the non-core instances and a list of the vertical layers and their capacitance as a list of tuples.
"# Get the current design block
block = design.getBlock()

# Get all the instances
insts = block.getInsts()

# Find the instance with the name '_411_'
inst = block.findInst('_411_')

# Dictionary to store signal types in nets
signal_type_dict = {}

# Check if instance '411' is type ENDCAP or any of its subtypes
print(""End cap status of cell '_411_':"", inst.isEndCap())

# Loop through all instances
for inst in insts:
    # Check if any of the user flags are set to true
    if inst.getUserFlag1() or inst.getUserFlag2() or inst.getUserFlag3():
        # Set the level of the instance to 1
        inst.setLevel(1)
    
    # Check if the instance name is 'input1'
    if inst.getName() == ""input1"":
        # Get the nets connected to 'input1' instance
        nets = [pin.getNet() for pin in inst.getITerms()]
        
        # Iterate through each net
        for net in nets:
            # Check if the net exists
            if net:
                # Store the signal type of the net in the dictionary
                signal_type_dict[net.getName()] = net.getSigType()
        break

# Return the dictionary containing signal types in nets
return signal_type_dict","Check if the library cell of instance '_411_' is type ENDCAP and get all the instances whose user flags are set and set those instances to level 1, also get the signal types in the nets of instance 'input1'"
"# Set userFlags 1 and 3 true for instance '411' and retrieve the LEQ (Logic Equivalent) information associated with the library cell of instance '411'.

# Get the dsign block
block = design.getBlock()

# Find the instance '411'
inst = block.findInst(""_411_"")

# Set userFlags 1 and 3 true
inst.setUserFlag1()
inst.setUserFlag3()

# Get the library cell of instance '411'
master = inst.getMaster()

# Retrieve the LEQ information associated with the library cell
LEQ = master.getLEQ()

# Return LEQ
return LEQ",Set userFlags 1and 3 true for instance '411' and retrieves the LEQ (Logic Equivalent) information associated with the library cell of instance '411'.
"# Get the location of the instances whose library cell is 'AND2_X1' and get rotation of instance whose library cells are of type 'NAND2_X1'.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store offset of 'AND2_X1' instances and location of 'NAND2_X1' instances
offset_dict_AND = {}
orient_dict_NAND = {}

# Iterate through instances
for inst in insts:
    # Check if the master cell name contains 'AND2_X1'
    if inst.getMaster().getName() == ""AND2_X1"":
        # Get transform and store offset
        transform = inst.getTransform()
        offset_dict_AND[inst.getName()] = transform.getOffset()
    
    # Check if the master cell name contains 'NAND2_X1'
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Get transform and store location
        transform = inst.getTransform()
        orient_dict_NAND[inst.getName()] = transform.getOrient()

# Return dictionaries of offsets and locations
return (offset_dict_AND, orient_dict_NAND)",Get the location of the instances whose library cell is 'AND2_X1' as a dicitonary with instance names as keys and get rotation of instance whose library cells are of type 'NAND2_X1'.
"# Set all the COVER master cells to frozen

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through instances
for inst in insts:
    # Get the master of the instance
    master = inst.getMaster()        
    # Check if the master is of type COVER
    if master.isCover():
        # Set the COVER master cell to frozen so dbMTerms cannot be added or delete from the master
        master.setFrozen()",set all the COVER master cells to frozen
"# Invert transforms of the instances whose master cells are 'NAND2_X1' 
# and get the offset of the transform of instance '411' and 'input1'.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store offset of transforms for instances '_411_' and 'input1'
inst_transform_offset = {}

# Iterate through instances
for inst in insts:
    # Check if the master cell name is 'NAND2_X1'
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Get transform and invert
        transform = inst.getTransform()
        transform.invert()
    
    # Check if instance name is '411' or 'input1'
    if inst.getName() == '_411_' or inst.getName() == 'input1':
        # Get transform and store offset
        transform = inst.getTransform()
        inst_transform_offset[inst.getName()] = transform.getOffset()

# Return dictionary containing offsets for instances '411' and 'input1'
return inst_transform_offset","Invert the location and rotation of instances whose library cells are 'NAND2_X1'. Then, retrieve the location of the instances '_411_' and 'input1' and return them as a dictionary with the instance names as keys and their respective location as values."
"# Get All the nets of the instances whose signal type is ""SIGNAL"" and get all the blockages.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# List to store nets with signal type 'SIGNAL'
nets = []

# Iterate through instances
for inst in insts:
    # Get all pins of the instance
    pins = inst.getITerms()
    # Iterate through pins
    for pin in pins:
        # Check if the signal type is 'SIGNAL'
        if pin.getSigType() == 'SIGNAL':
            # Add the net to the list
            nets.append(pin.getNet())

# Get all blockages in the block
blockages = block.getBlockages()

# Return a tuple containing the list of nets and blockages
return (nets, blockages)","Get a list of all the nets of the instances whose signal type is ""SIGNAL"" and get all the blockages. Return the result as a tuple"
"# Get the design block
block =design.getBlock()

# Reset the tapcell in the design
tapcell = design.getTapcell()
tapcell.reset()

# Retrieve the coupling capacitance segments
coupling_segments = block.getCCSegs()

# Return the coupling capacitance segments
return coupling_segments",Reset the tapcell in the design and retrieve the coupling capacitance segments of the design block.
"# Get the list of hierarchical filler cell instances.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# List to store hierarchical instances with filler cells
inst_list = []

# Iterate through instances
for inst in insts:
    # Check if the instance is hierarchical and its master is a filler cell
    if inst.isHierarchical() and inst.getMaster().isFiller():
        inst_list.append(inst)

# Return hierarchical instances with filler cells
return inst_list",Get the list of hierarchical filler cell instances.
"# Get the resistor segments and get the sites of rows
block = design.getBlock()
resistor_segments = block.getRSegs()

# Get the sites of rows
rows = block.getRows()
hybrid_rows = {}
for row in rows:
    if row.getSite().isHybrid():
        hybrid_rows[row] = row.getSite()

# Return resistor segments and hybrid rows
return (resistor_segments, hybrid_rows)
","Get the resistor segments and a dictionary of the hybrid sites of the rows, with the row as the key and the site as the value."
"# Get source type of all the instance on level 1 with filler cells and set the placement Status of the instance 'input1' to 'UNPLACED'.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store source types
source_dict = {}

# Iterate through instances
for inst in insts:
    # Check if the instance's master is a filler cell and it is set as level 1
    if inst.getMaster().isFiller() and inst.getLevel() == 1:
        # Get and store the source type
        source_dict[inst.getName()] = inst.getSourceType()
    
    # Check if the instance is 'input1' and set its placement status to 'UNPLACED'
    if inst.getName() == ""input1"":
        inst.setPlacementStatus('UNPLACED')

# Return source types
return source_dict
","Get source type of all the filler cell instances set as level 1 as a dictionary with inst name as keys. Also, set the placement status flag of the instance 'input1' to 'UNPLACED'."
"# Set the alias of the layers by the naming convention ''LayerXi"" where i is the index of the layer and get the status of USEMINSPACING for pins in LEF. return the results as a dict with each requirement as key names.

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers
layers = tech.getLayers()

# Initialize a dictionary to store the Alias of each layer
layer_alias = {}

# Iterate through all layers
for layer in layers:
    # Construct the Alias using the layer index
    alias = ""LayerX"" + str(layer.getNumber())
    
    # Set the Alias of the layer
    layer.setAlias(alias)
    
    # Store the Alias of the layer in the dictionary
    layer_alias[layer.getName()] = alias
    
# Get the status of USEMINSPACING for pins in LEF
min_spacing_pin = tech.getUseMinSpacingPin()

# Return the dictionary containing the updated Alias of layers
return {
    ""Alias"": layer_alias,
    ""min_spacing_pin"": min_spacing_pin
}","Set the alias of the layers by the naming convention ''LayerXi"" where i is the index of the layer and get the status of USEMINSPACING for pins in LEF. return the results as a dict with each requirement as key names."
"# Get the current block of the design
block = design.getBlock()

# Find the instances '_411_' and 'input1'
inst1 = block.findInst('_411_')
inst2 = block.findInst('input1')

# Get the library cells of the instances
master1 = inst1.getMaster()
master2 = inst2.getMaster()

# Get the MTerms of the library cell of the instance '_411_'
mterms1 = master1.getMTerms()

# Get the MTerms of the library cell of the instance 'input1'
mterms2 = master2.getMTerms()

# List to store input MTerms of the instance 'input1'
input_mterms = []

# Iterate through each MTerm of the instance 'input1'
for mterm in mterms2:
    # Check if the IoType is 'INPUT'
    if mterm.getIoType() == 'INPUT':
        # Append the MTerm to the list of input MTerms
        input_mterms.append(mterm)

# Return a tuple containing MTerms of the library cell of instance '_411_' and input MTerms of instance '_411_'
return (mterms1, input_mterms)",Get the MTerms of the library cell of the instance '_411_' and get the list of mterms of the instance 'input1' whose IoType is 'INPUT'. Return the results as a tuple
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the LEF version of the technology
lef_version = tech.getLefVersion()

# get clearance measure of the technology
clearance_measure = tech.getClearanceMeasure()

# Set Db units per micron to 1500 for the chip
tech.setDbUnitsPerMicron(1500)

# Return the clearance measure and the LEF version of the technology
return (clearance_measure, lef_version)",Get the clearance measure and set the Db units per micron to 1500 to the chip and get Lef version. return the result as a tuple.
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Find the layer 'metal5' in the technology
layer = tech.findLayer('metal5')

# Get the upper and lower layers of the layer 'metal5'
upper_lower_layer = {
    ""upper"": layer.getUpperLayer(),
    ""lower"": layer.getLowerLayer()
}

# Get the top layer of the IO Placer object of the design
iop = design.getIOPlacer()
iop_top_layer = iop.getTopLayer()

# Return a tuple containing the upper and lower layer of 'metal5' and the top layer used for the IO pin placer
return (upper_lower_layer, iop_top_layer)","Retrieve the upper and lower layers of the 'metal5' layer and encapsulate them in a dictionary with ""upper"" and ""lower"" as keys. Additionally, retrieve the setting of the top layer used for the IO pin placer. Return the results as a tuple."
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Initialize a list to store output pins without nets
output_pin_wout_net = []
# Iterate over instances
for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate over pins
        for pin in pins:
                # Check if the pin is an output signal
                if pin.isOutputSignal():
                        # Get the net connected to the pin
                        nets = pin.getNet()
                        # Check if the pin has no net connected
                        if nets == None:
                                # Append the pin to the list
                                output_pin_wout_net.append(pin)
# Check if there are no output pins without nets
if len(output_pin_wout_net) == 0:
    return True
else:
    return False        ",Check if all the output pins of all instances have a valid net connection
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Initialize a list to store input pins without nets
input_pin_wout_net = []
# Iterate over instances
for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate over pins
        for pin in pins:
                # Check if the pin is an input signal
                if pin.isInputSignal():
                        # Get the net connected to the pin
                        nets = pin.getNet()
                        # Check if the pin has no net connected
                        if nets == None:
                                # Append the pin to the list
                                input_pin_wout_net.append(pin)
# Check if there are no input pins without nets
if len(input_pin_wout_net) == 0:
    return True
else:
    return False",Check if all the input pins of all instances have a valid net connection
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_split30_""
inst = block.findInst(""_split30_"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","Set the instance ""_split30_"" as don't touch type"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_split30_""
inst = block.findInst(""_split30_"")
# Set the instance as don't touch type
inst.setDoNotTouch(False)","Reset the instance ""_split30_"" as don't touch type"
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store pin names
pin_name_list = []
# Loop through all instances
for inst in insts:
    # Get the pins of this instance
    inst_ITerms = inst.getITerms()
    # Loop through all pins
    for ITerm in inst_ITerms:
        # Append pin names to the list
        pin_name_list.append(design.getITermName(ITerm))
return pin_name_list",Get the name of every pin
"# Get the placement status of all instances

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store unplaced instances
unplaced_instances = []

# Iterate through all instances
for inst in insts:
    # Print the instance name and its placement status
    print(inst.getName(), inst.getPlacementStatus())
    # Check if the instance is not placed
    if not inst.isPlaced():
        # If the instance is not placed, add it to the list of unplaced instances
        unplaced_instances.append(inst)

# Return the list of unplaced instances
return unplaced_instances
",get the all the unplaced instance as a list
"# Get the design block
block = ord.get_db_block()
# Get instances from
insts = block.getInsts()
# Initialize a dictionary to store instances with MUX2_X2 master
mux_ins_dict = {}

# Iterate over instances
for inst in insts:
        # Get the master of the instance
        mast = inst.getMaster()
        # Check if the master is MUX2_X2 
        if 'MUX2_X2' == mast.getName():
                # Check if instance name is already in the dictionary
                if inst.getName() not in mux_ins_dict:
                        mux_ins_dict[inst.getName()] = [mast.getName()]
                else:
                        mux_ins_dict[inst.getName()].append(mast.getName())

# Return the dictionary
return mux_ins_dict","Return a dictionary with the keys being the names of all MUX2_X2 cells, and the values being the name of the library cell"
"# Get the nets of all input pins

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store nets of input pins
input_net_list = []

# Iterate through all instances
for inst in insts:
    # Get all input pins (ITerms) of the instance
    pins = inst.getITerms()
    # Iterate through all input pins
    for pin in pins:
        # Check if the pin is an input signal
        if pin.isInputSignal():
            # If it's an input signal, add its net to the list
            input_net_list.append(pin.getNet())

# Return the list of nets of input pins
return input_net_list",Get the nets of all input pins
"# Get the nets of all output pins

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store nets of output pins
output_net_list = []

# Iterate through all instances
for inst in insts:
    # Get all input pins (ITerms) of the instance
    pins = inst.getITerms()
    # Iterate through all input pins
    for pin in pins:
        # Check if the pin is an output signal
        if pin.isOutputSignal():
            # If it's an output signal, add its net to the list
            output_net_list.append(pin.getNet())

# Return the list of nets of output pins
return output_net_list",get the nets of all output pins
"# Get each net's fanout count, in the form of a dictionary, with net name as key and number of fanout as value
# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a dictionary to store fanout information
fanout_dict = {}

# Iterate through all instances
for inst in insts:
    # Get all pins (ITerms) of the instance
    pins = inst.getITerms()
    # Iterate through all pins
    for pin in pins:
        # Get the net associated with the pin
        net = pin.getNet()
        # Get the name of the net
        name = net.getName() if net else None
        # Check if the pin is an input signal
        if pin.isInputSignal():
            # If it's an input signal, increment the fanout count for the net
            if name in fanout_dict:
                fanout_dict[name] += 1
            else:
                fanout_dict[name] = 1
        else:
            # If it's not an input signal, initialize the fanout count for the net to 0
            if name not in fanout_dict:
                fanout_dict[name] = 0

# Return the fanout dictionary
return fanout_dict","Get each net's fanout count, in the form of a dictionary, with net name as key and number of fanout as value"
"# Get all the instances on level 0

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Level to filter instances
level = 0

# Initialize a list to store instances on the specified level
insts_on_level = []

# Iterate through all instances
for inst in insts:
    # Check if the instance's level matches the specified level
    if inst.getLevel() == level:
        # If it's on the specified level, add it to the list
        insts_on_level.append(inst)

# Return the list of instances on the specified level
return insts_on_level",Get all the instances on level 0
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst('input20')
# Set the orientation of the instance as ""R0""
inst.setOrient('R0')",Set the orientation of an instance 'input20' as 'R0'
"# Get the output pins of the instance 'output53'

# Get the design block
block = design.getBlock()

# Get all instances
inst = block.findInst('output53')

# Initialize a variable to store the output pin
output_pins = []

# Get all input pins (ITerms) of the instance
pins = inst.getITerms()

# Iterate through all input pins
for pin in pins:
    # Check if the pin is an output signal
    if pin and pin.isOutputSignal() :
        # If it's an output signal, store it as the output pin
        output_pins.append(pin)

# Return the output pin of the specified instance
return output_pins",get the output pins of the instance 'output53'
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store instances with pins set as clocked
clock_insts = []

# Iterate through all instances
for inst in insts:
    
    pins = inst.getITerms()
    for pin in pins:
        if pin.isClocked():
            clock_insts.append(inst)

# Return the list of instances with pins set as clocked
return clock_insts",get the instances that have pins set as clocked
"# Get all the pins whose 'IO type' is 'INPUT'.

# Get the design block
block = design.getBlock()

# Get all pins (ITerms)
pins = block.getITerms()

# Initialize a list to store input pins
input_pins = []

# Iterate through all pins
for pin in pins:
    # Check if the pin's IO type is INPUT
    if pin.getIoType() == 'INPUT':
        # If it's an input pin, add it to the list
        input_pins.append(pin)

# Return the list of input pins
return input_pins",Get all the pins whose 'IO type' is 'INPUT'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the DB units per micron
return block.getDbUnitsPerMicron()",Convert 1 micron to units used in this technology in OpenROAD
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the DB units per micron
return block.getDbUnitsPerMicron()",Convert 1 micrometer to units used in this technology in OpenROAD
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst(""input1"")
# Check if the user-defined flag 1 of the instance is set true
if inst.getUserFlag1()==True:
        # Clear the user flag 1 of the instance        
        inst.clearUserFlag1()","Clear the user-defined flag 1 on the instance with name ""input1"" if the flag is set"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name 'poly'
layer = tech.findLayer('poly')
# Return the layer above the layer
return layer.getUpperLayer()",Get the layer above the layer with name 'poly'
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Initialize a list to store output pins without nets
output_pin_wout_net = []
# Iterate over instances
for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate over pins
        for pin in pins:
                # Check if the pin is an output signal
                if pin.isOutputSignal():
                        # Get the net connected to the pin
                        nets = pin.getNet()
                        # Check if the pin has no net connected
                        if nets == None:
                                # Append the pin to the list
                                output_pin_wout_net.append(pin)
# Check if there are no output pins without nets
if len(output_pin_wout_net) == 0:
    return True
else:
    return False        ",Check if all the output pins of all instances have a valid net connection
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Initialize a list to store input pins without nets
input_pin_wout_net = []
# Iterate over instances
for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate over pins
        for pin in pins:
                # Check if the pin is an input signal
                if pin.isInputSignal():
                        # Get the net connected to the pin
                        nets = pin.getNet()
                        # Check if the pin has no net connected
                        if nets == None:
                                # Append the pin to the list
                                input_pin_wout_net.append(pin)
# Check if there are no input pins without nets
if len(input_pin_wout_net) == 0:
    return True
else:
    return False",Check if all the input pins of all instances have a valid net connection
"# Get the design block
block = ord.get_db_block()        
# Get all nets
nets = block.getNets()
# Define the fanout threshold
gt_fanout = 6
# Initialize a list to store nets with fanout greater than the threshold
net_fanout = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) > gt_fanout:
                 # Append the net name and its fanout to the list
                 net_fanout.append([net_name, len(output_pins)])
# Return the list of nets with fanout greater than the threshold
return net_fanout",Give me a list of nets with a fanout greater than 6
"# Get the design block
block = ord.get_db_block()        
# Get all nets
nets = block.getNets()
# Define the fanout threshold
gt_fanout = 6
# Initialize a list to store nets with fanout greater than the threshold
net_fanout = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) < gt_fanout:
                 # Append the net name and its fanout to the list
                 net_fanout.append([net_name, len(output_pins)])
# Return the list of nets with fanout greater than the threshold
return net_fanout",Give me a list of nets with a fanout less than 6
"# Get the design block
block = ord.get_db_block()        
# Get all nets
nets = block.getNets()
# Define the fanout threshold
gt_fanout = 5
# Initialize a list to store nets with fanout greater than the threshold
net_fanout = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) > gt_fanout:
                 # Append the net name and its fanout to the list
                 net_fanout.append([net_name, len(output_pins)])
# Return the list of nets with fanout greater than the threshold
return net_fanout",Give me a list of nets with a fanout greater than 5
"# Get the design block
block = ord.get_db_block()        
# Get all nets
nets = block.getNets()
# Define the fanout threshold
gt_fanout = 5
# Initialize a list to store nets with fanout greater than the threshold
net_fanout = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) < gt_fanout:
                 # Append the net name and its fanout to the list
                 net_fanout.append([net_name, len(output_pins)])
# Return the list of nets with fanout greater than the threshold
return net_fanout",Give me a list of nets with a fanout less than 5
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the def units to 1500 as mentioned in the prompt
block.setDefUnits(1500)",Set the def units to 1500
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 5 ns as mentioned in the prompt                
                if pin_rise_arr >= 5e-9:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 5 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 132 ps as mentioned in the prompt                
                if pin_rise_arr >= 1.32e-10:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 132 ps and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 132 picosecond as mentioned in the prompt                
                if pin_rise_arr >= 1.32e-10:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 132 picosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 5 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 5e-9:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 5 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 18 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 1.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 18 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 18 ns as mentioned in the prompt                
                if pin_rise_arr >= 1.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 18 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 142 ns as mentioned in the prompt                
                if pin_rise_arr >= 1.42e-7:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 142 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 142 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 1.42e-7:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 142 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 321 ns as mentioned in the prompt                
                if pin_rise_arr >= 3.21e-7:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 321 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 321 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 3.21e-7:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 321 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 28 ns as mentioned in the prompt                
                if pin_rise_arr >= 2.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 28 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than or equal 28 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 2.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin rising arrival time greater than or equal to 28 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rise arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rise arrival time is greater than or equal 6 nanoseconds as mentioned in the prompt                
                if pin_rise_arr >= 0.000000006:
                        output.append(pin)
return output",Get all the pins which has a pin rise arrival time greater than or equal to 6 nanoseconds in the block and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rise arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rise arrival time is less than or equal 0.4 second as mentioned in the prompt
                if pin_rise_arr <= 0.4:
                        # Append the pin to the output
                        output.append(pin)
return output",Get all the pins which has a pin rise arrival time less than or equal to 0.4 seconds in the block and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the fall arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the fall arrival time is less than or equal to 0.1 seconds as mentioned in the prompt
                if pin_fall_arr <= 0.1:
                        # Append the pin to the output
                        output.append(pin)
return output",Get all the pins which has a pin fall arrival time less than or equal to 0.1 second in the block and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 5 ns as mentioned in the prompt                
                if pin_rise_arr >= 5e-9:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 5 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 132 ps as mentioned in the prompt                
                if pin_rise_arr >= 1.32e-10:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 132 ps and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 132 picosecond          
                if pin_rise_arr >= 1.32e-10:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 132 picosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 5 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 5e-9:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 5 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 18 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 1.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 18 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 18 ns as mentioned in the prompt                
                if pin_rise_arr >= 1.8e-8:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 18 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 142 ns as mentioned in the prompt                
                if pin_rise_arr >= 1.42e-7:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 142 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 142 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 1.42e-7:
                        output.append(pin)
return output",Get all the pins which has a pin falling arrival time greater than or equal to 142 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is less than or equal to 0.1 seconds as mentioned in the prompt
                if pin_fall_arr <= 0.1:
                        # Append the pin to the output
                        output.append(pin)
return output",Get all the pins which has a falling arrival time less than or equal to 0.1 second in the block and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 8 ns as mentioned in the prompt                
                if pin_rise_arr >= 8e-9:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 8 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 118 ps as mentioned in the prompt                
                if pin_rise_arr >= 1.18e-10:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 118 ps and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 118 picosecond          
                if pin_rise_arr >= 1.18e-10:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 118 picosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 9 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 9e-9:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 9 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 18 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 0.000000018:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 18 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 18 ns as mentioned in the prompt                
                if pin_rise_arr >= 0.000000018:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 18 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 142 ns as mentioned in the prompt                
                if pin_rise_arr >= 0.000000142:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 142 ns and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins belong to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the falling arrival time is greater than or equal 142 nanosecond as mentioned in the prompt                
                if pin_rise_arr >= 0.000000142:
                        output.append(pin)
return output",Get all the pins which has a falling arrival time greater than or equal to 142 nanosecond and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""input2"" as mentioned in the prompt
inst = block.findInst(""input2"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the X Minimum of the bounding box of the instance
xmin = BBox.xMin()
# Get the Y Minimum of the bounding box of the instance
ymin = BBox.yMin()
# Get the X Maximum of the bounding box of the instance
xmax = BBox.xMax()
# Get the Y Maximum of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Give me the bounding box of the instance ""input2"", and provide a list of coordinates, with (Xmin, Ymin) in one list, and (Xmax, Ymax) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""input2"" as mentioned in the prompt
inst = block.findInst(""input2"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the x_min of the bounding box of the instance
xmin = BBox.xMin()
# Get the y_min of the bounding box of the instance
ymin = BBox.yMin()
# Get the x_max of the bounding box of the instance
xmax = BBox.xMax()
# Get the y_max of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""input2"", and provide a list of coordinates, with (x_min, y_min) in one list, and (x_max, y_max) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the X Minimum of the bounding box of the instance
xmin = BBox.xMin()
# Get the Y Minimum of the bounding box of the instance
ymin = BBox.yMin()
# Get the X Maximum of the bounding box of the instance
xmax = BBox.xMax()
# Get the Y Maximum of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""_cell1\_124_"", and provide a list of coordinates, with (Xmin, Ymin) in one list, and (Xmax, Ymax) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the x_min of the bounding box of the instance
xmin = BBox.xMin()
# Get the y_min of the bounding box of the instance
ymin = BBox.yMin()
# Get the x_max of the bounding box of the instance
xmax = BBox.xMax()
# Get the y_max of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""_cell1\_124_"", and provide a list of coordinates, with (x_min, y_min) in one list, and (x_max, y_max) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_buff132_""
inst = block.findInst(""_buff132_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the X Minimum of the bounding box of the instance
xmin = BBox.xMin()
# Get the Y Minimum of the bounding box of the instance
ymin = BBox.yMin()
# Get the X Maximum of the bounding box of the instance
xmax = BBox.xMax()
# Get the Y Maximum of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Give me the bounding box of the instance ""_buff132_"", and provide a list of coordinates, with (Xmin, Ymin) in one list, and (Xmax, Ymax) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_buff132_""
inst = block.findInst(""_buff132_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the x_min of the bounding box of the instance
xmin = BBox.xMin()
# Get the y_min of the bounding box of the instance
ymin = BBox.yMin()
# Get the x_max of the bounding box of the instance
xmax = BBox.xMax()
# Get the y_max of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""_buff132_"", and provide a list of coordinates, with (x_min, y_min) in one list, and (x_max, y_max) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_buff132_""
inst = block.findInst(""_buff132_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the Min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the Min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the Max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the Max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""_buff132_"", and provide a list of coordinates, with (Min_x, Min_y) in one list, and (Max_x, Max_y) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_buff132_""
inst = block.findInst(""_buff132_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""_buff132_"", and provide a list of coordinates, with (min_x, min_y) in one list, and (max_x, max_y) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""temp_inst""
inst = block.findInst(""temp_inst"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the Min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the Min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the Max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the Max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Retrieve the bounding box of the instance ""temp_inst"", and provide a list of coordinates, with (Min_x, Min_y) in one list, and (Max_x, Max_y) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""temp_inst""
inst = block.findInst(""temp_inst"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","Give me the bounding box of the instance ""temp_inst"", and provide a list of coordinates, with (min_x, min_y) in one list, and (max_x, max_y) in the next list"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""inst01""
inst = block.findInst(""inst01"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the Min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the Min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the Max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the Max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","How can I get the bounding box of the instance ""inst01"", and provide a list of coordinates, with (Min_x, Min_y) in one list, and (Max_x, Max_y) in the next list?"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""temp_inst""
inst = block.findInst(""temp_inst"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the min_x of the bounding box of the instance
xmin = BBox.xMin()
# Get the min_y of the bounding box of the instance
ymin = BBox.yMin()
# Get the max_x of the bounding box of the instance
xmax = BBox.xMax()
# Get the max_y of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","How can I get the bounding box of the instance ""temp_inst"", and provide a list of coordinates, with (min_x, min_y) in one list, and (max_x, max_y) in the next list?"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the X Minimum of the bounding box of the instance
xmin = BBox.xMin()
# Get the Y Minimum of the bounding box of the instance
ymin = BBox.yMin()
# Get the X Maximum of the bounding box of the instance
xmax = BBox.xMax()
# Get the Y Maximum of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","How can I get the bounding box of the instance ""_cell1\_124_"", and provide a list of coordinates, with (Xmin, Ymin) in one list, and (Xmax, Ymax) in the next list?"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Get the Bounding box of the instance
BBox = inst.getBBox()
# Get the x minimum of the bounding box of the instance
xmin = BBox.xMin()
# Get the y minimum of the bounding box of the instance
ymin = BBox.yMin()
# Get the x maximum of the bounding box of the instance
xmax = BBox.xMax()
# Get the y maximum of the bounding box of the instance
ymax = BBox.yMax()
return [[xmin,ymin],[xmax,ymax]]","How can I get the bounding box of the instance ""_cell1\_124_"", and provide a list of coordinates, with (xmin, ymin) in one list, and (xmax, ymax) in the next list?"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1200 as mentioned in the prompt
block.setDefUnits(1200)",Establish the units per micron as 1200.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1200 as mentioned in the prompt
block.setDefUnits(1200)",Set the units per micron to 1200.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1200 as mentioned in the prompt
block.setDefUnits(1200)",Set the DEF units of this technology to 1200.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1200 as mentioned in the prompt
block.setDefUnits(1200)",How can I set the DEF units of this technology to 1200?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1600 as mentioned in the prompt
block.setDefUnits(1600)",Establish the units per micron as 1600.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1600 as mentioned in the prompt
block.setDefUnits(1600)",Set the units per micron to 1600.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1600 as mentioned in the prompt
block.setDefUnits(1600)",Set the DEF units of this technology to 1600.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1600 as mentioned in the prompt
block.setDefUnits(1600)",How can I set the DEF units of this technology to 1600?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1500 as mentioned in the prompt
block.setDefUnits(1500)",Establish the units per micron as 1500.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1500 as mentioned in the prompt
block.setDefUnits(1500)",Set the units per micron to 1500.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1500 as mentioned in the prompt
block.setDefUnits(1500)",Set the DEF units of this technology to 1500.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the DEF units of this technology to 1500 as mentioned in the prompt
block.setDefUnits(1500)",How can I set the DEF units of this technology to 1500?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input2' as mentioned in the prompt
inst = block.findInst(""input2"")
inst.setUserFlag1()","Assign the value of true for user-defined flag 1 for the instance named ""input2""."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name 'input3' as mentioned in the prompt
inst = block.findInst('input3')
# Get all the pins connected to an instance
pins = inst.getITerms()
# Initialize a nets array
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Initialize the count with 0
count = 0
# Iterate through all the nets
for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
                # Increase the count
                count+=1
return count",Provide the count of modified nets connected to the instance 'input3'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_cell1\_124_' as mentioned in the prompt
inst = block.findInst('_cell1\_124_')
# Get all the pins connected to an instance
pins = inst.getITerms()
# Initialize a nets array
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Initialize the count with 0
count = 0
# Iterate through all the nets
for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
                # Increase the count
                count+=1
return count",Provide the count of modified nets connected to the instance '_cell1\_124_'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_buff132_'
inst = block.findInst('_buff132_')
# Get all the pins connected to an instance
pins = inst.getITerms()
# Initialize a nets array
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Initialize the count with 0
count = 0
# Iterate through all the nets
for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
                # Increase the count
                count+=1
return count",Provide the count of modified nets connected to the instance '_buff132_'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name 'input2'
inst = block.findInst('input2')
# Get all the pins connected to an instance
pins = inst.getITerms()
# Initialize a nets array
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Initialize the count with 0
count = 0
# Iterate through all the nets
for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
                # Increase the count
                count+=1
return count",Provide the count of modified nets connected to the instance 'input2'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name 'input4' as mentioned in the prompt
inst = block.findInst('input4')
# Get all the pins connected to an instance
pins = inst.getITerms()
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Iterate through all the nets
for net in nets:
        # Check if the wire is altered
        if net.isWireAltered():
                return True
return False","Examine all nets connected to the instance 'input4' to see if any have been modified. Return True if modified, and False otherwise."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_buff132_' as mentioned in the prompt
inst = block.findInst('_buff132_')
# Get all the pins connected to an instance
pins = inst.getITerms()
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Iterate through all the nets
for net in nets:
        # Check if the wire is altered
        if net.isWireAltered():
                return True
return False","Examine all nets connected to the instance '_buff132_' to see if any have been modified. Return True if modified, and False otherwise."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_buff132_'
inst = block.findInst('_buff132_')
# Get all the pins connected to an instance
pins = inst.getITerms()
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Iterate through all the nets
for net in nets:
        # Check if the wire is altered
        if net.isWireAltered():
                return True
return False","Help me write a piece of code that examine all nets connected to the instance '_buff132_' to see if any have been modified. Return True if modified, and False otherwise."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_cell1\_124_'
inst = block.findInst('_cell1\_124_')
# Get all the pins connected to an instance
pins = inst.getITerms()
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Iterate through all the nets
for net in nets:
        # Check if the wire is altered
        if net.isWireAltered():
                return True
return False","Examine all nets connected to the instance '_cell1\_124_' to see if any have been modified. Return True if modified, and False otherwise."
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find an instance with name '_cell1\_124_' as mentioned in the prompt
inst = block.findInst('_cell1\_124_')
# Get all the pins connected to an instance
pins = inst.getITerms()
nets = []
# Iterate through all the pins
for pin in pins:
        # Get the net the pin
        nets.append(pin.getNet())
# Iterate through all the nets
for net in nets:
        # Check if the wire is altered
        if net.isWireAltered():
                return True
return False","Help me write a piece of code that examine all nets connected to the instance '_cell1\_124_' to see if any have been modified. Return True if modified, and False otherwise."
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","Set the instance ""input03"" as don't touch type"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","How can I set the instance ""input03"" as don't touch?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","Set the instance ""_cell1\_124_"" as don't touch type"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","How can I set the instance ""_cell1\_124_"" as don't touch?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","Reset the instance ""input03""'s don't touch flag"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","How can I reset the instance ""input03""'s don't touch flag?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","Reset the instance ""_cell1\_124_""'s don't touch flag"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","How can I reset the instance ""_cell1\_124_""'s don't touch flag?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","Reset the instance ""input03""'s don't touch setting"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","How can I reset the instance ""input03""'s don't touch setting?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","Reset the instance ""_cell1\_124_""'s don't touch setting"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_cell1\_124_""
inst = block.findInst(""_cell1\_124_"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","How can I reset the instance ""_cell1\_124_""'s don't touch setting?"
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","Reset the don't touch setting of instance ""input03"""
"# Get the design block
block = ord.get_db_block()
# Find the instance ""input03""
inst = block.findInst(""input03"")
# Reset the instance's don't touch flag
inst.setDoNotTouch(False)","How can I reset the don't touch setting of instance ""input03""?"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the number of layers in this technology.
return tech.getLayerCount()",Retrieve the count of layers in this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the number of layers in this technology.
return tech.getLayerCount()",How can I get the count of layers in this technology?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the number of layers in this technology.
return tech.getLayerCount()",Write a piece of code help me get the amount of layers in this technology
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the count of types of vias supported by this technology.
return tech.getViaCount()",Retrieve the count of types of vias supported by this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the count of types of vias supported by this technology.
return tech.getViaCount()",How can I get the count of types of vias supported by this technology?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Return the count of types of vias supported by this technology.
return tech.getViaCount()",Write a piece of code to get the count of types of vias supported by this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'metal1' layer
layer = tech.findLayer('metal1')
# Return the layer above the layer
return layer.getUpperLayer()",Retrieve the layer above the layer named 'metal1'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'M3' layer
layer = tech.findLayer('M3')
# Return the layer above the layer
return layer.getUpperLayer()",Give me the technology layer above the layer named 'M3'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'metal1' layer
layer = tech.findLayer('metal1')
# Return the layer above the layer
return layer.getUpperLayer()",Help me get the layer above the layer named 'metal1'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'metal2' layer
layer = tech.findLayer('metal2')
# Return the layer above the layer
return layer.getUpperLayer()",How can I get the layer above the layer named 'metal2'?
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'Via3' layer
layer = tech.findLayer('Via3')
# Return the layer above the layer
return layer.getUpperLayer()",Give me the technology layer above the layer named 'Via3'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'via3' layer
layer = tech.findLayer('via3')
# Return the layer above the layer
return layer.getUpperLayer()",Give me the technology layer above the layer named 'via3'.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology info
tech = block.getTech()
# Find the 'M4' layer
layer = tech.findLayer('M4')
# Return the layer above the layer
return layer.getUpperLayer()",Help me get the layer above the layer named 'M4'.
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check the placement status
inst_name = 'FILLER_0_3_49'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",Verify if the instance 'FILLER_0_3_49' is placed or not
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check the placement status
inst_name = 'input3'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",Verify if the instance 'input3' is placed or not
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check the placement status
inst_name = 'input3'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",How can I know if the instance 'input3' is placed or not?
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check the placement status
inst_name = 'input3'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",Help me write a piece of script to know if the instance 'input3' is placed or not
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Name of the instance to check the placement status
inst_name = 'cell_12\132'

# Iterate through all instances
for inst in insts:
    # Check if the instance name matches the target instance
    if inst.getName() == inst_name:
        # Return the placement status of the instance
        return inst.isPlaced()",Help me write a piece of script to know if the instance 'cell_12\132' is placed or not
"# Get the design block
block = design.getBlock()

# Find the instance with name 'PHY_21'
inst = block.findInst('PHY_21')

# Get the MTerms
mterms = inst.getMaster().getMTerms()

# Return the MTerms
return mterms
","
# Retrieve the MTerms of the master cell of the instance 'PHY_21'"
"# Get the design block
block = design.getBlock()

# Retrieve all instances
insts = block.getInsts()

# Initialize an empty list to store instances with INV_X1 cell
inst_list = []

# Iterate over each instance in the design
for inst in insts:
    # Get the master of the current instance
    master = inst.getMaster()
    # Check if the master's name matches ""INV_X1""
    if master.getName() == ""INV_X1"":
        # Append the current instance to the list
        inst_list.append(inst)

# Return the list of instances with INV_X1 cell
return inst_list",get the instances with INV_X1 cell
"# Get length and width of the bounding box of the instance '_590_'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_590_')

# Get the length and width of the bounding box of the instance
length = inst.getBBox().getLength()
width = inst.getBBox().getWidth()

# Return the length and width
return (length, width)",Help me get the length and width of the bounding box of the instance '_590_'
"# Get length and width of the bounding box of the instance '_590_'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_590_')

# Get the length and width of the bounding box of the instance
length = inst.getBBox().getLength()
width = inst.getBBox().getWidth()

# Return the length and width
return (length, width)",How can I get the length and width of the bounding box of the instance '_590_'?
"# Get length and width of the bounding box of the instance 'input118'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('input118')

# Get the length and width of the bounding box of the instance
length = inst.getBBox().getLength()
width = inst.getBBox().getWidth()

# Return the length and width
return (length, width)",Help me get the length and width of the bounding box of the instance 'input118'
"# Get length and width of the bounding box of the instance 'input118'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('input118')

# Get the length and width of the bounding box of the instance
length = inst.getBBox().getLength()
width = inst.getBBox().getWidth()

# Return the length and width
return (length, width)",How can I get the length and width of the bounding box of the instance 'input118'?
"# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store offset of 'MUX2_X1'
offset_dict = {}

# Iterate through instances
for inst in insts:
    # Check if the master cell name contains 'MUX2_X1'
    if inst.getMaster().getName() == ""MUX2_X1"":
        # Get the offset
        transform = inst.getTransform()
        offset_dict[inst.getName()] = transform.getOffset()

# Return dictionary
return offset_dict",get the offset of the instances whose library cell is 'MUX2_X1'
"# Get the IoType of the MTerms of the instance '_575_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_575_'
inst = block.findInst('_575_')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",get the IoType of the mterms of the instance '_575_'
"# Get the IoType of the MTerms of the instance 'split22'

# Get the design block
block = design.getBlock()

# Find the instance with name 'split22'
inst = block.findInst('split22')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",get the IoType of the mterms of the instance 'split22'
"# Get the IoType of the MTerms of the instance 'split22'

# Get the design block
block = design.getBlock()

# Find the instance with name 'split22'
inst = block.findInst('split22')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",How can I get the IoType of the mterms of the instance 'split22'?
"# Check if the instance '_373_' has any pin set as clocked

# Get the design block
block = design.getBlock()

# Find the instance '_373_'
inst = block.findInst('_373_')

# Get all pins of the instance
pins = inst.getITerms()

# List to store pins are set as clocked
clocked_ports = []

# Check if any pin is set as clocked
for pin in pins:
    if pin.isClocked():
        clocked_ports.append(pin)

# Return clocked ports
return clocked_ports",Check if the instance '_373_' has any pin set as clocked
"# Check if the instance '_373_' has any pin set as clocked

# Get the design block
block = design.getBlock()

# Find the instance '_373_'
inst = block.findInst('_373_')

# Get all pins of the instance
pins = inst.getITerms()

# List to store pins are set as clocked
clocked_ports = []

# Check if any pin is set as clocked
for pin in pins:
    if pin.isClocked():
        clocked_ports.append(pin)

# Return clocked ports
return clocked_ports",How can I know if the instance '_373_' has any pin set as clocked?
"# Check if the instance 'input112' has any pin set as clocked

# Get the design block
block = design.getBlock()

# Find the instance 'input112'
inst = block.findInst('input112')

# Get all pins of the instance
pins = inst.getITerms()

# List to store pins are set as clocked
clocked_ports = []

# Check if any pin is set as clocked
for pin in pins:
    if pin.isClocked():
        clocked_ports.append(pin)

# Return clocked ports
return clocked_ports",How can I know if the instance 'input112' has any pin set as clocked?
"# Get the design block
block = ord.get_db_block()
# Initialize a list to store clock nets
clock_nets = []
# Get all nets
nets = block.getNets()
# Iterate over nets
for net in nets:
    # Check if the net is a CLOCK net
    if net.getSigType() == 'CLOCK':
        # Check if the net is a CLOCK net
        clock_nets.append(net)
# Check if CLOCK nets exist
if len(clock_nets) > 0:
    return True
else:
    return False",How can I know if the design has any clock nets?
"# Get the design block
block = ord.get_db_block()
# Initialize a list to store clock nets
clock_nets = []
# Get all nets
nets = block.getNets()
# Iterate over nets
for net in nets:
    # Check if the net is a CLOCK net
    if net.getSigType() == 'CLOCK':
        # Check if the net is a CLOCK net
        clock_nets.append(net)
# Check if CLOCK nets exist
if len(clock_nets) > 0:
    return True
else:
    return False",Writre a piece of code to see if the design has any clock nets
"# Get the design block
block = ord.get_db_block()
# Initialize a list to store clock nets
clock_nets = []
# Get all nets
nets = block.getNets()
# Iterate over nets
for net in nets:
    # Check if the net is a CLOCK net
    if net.getSigType() == 'CLOCK':
        # Check if the net is a CLOCK net
        clock_nets.append(net)
# Check if CLOCK nets exist
if len(clock_nets) > 0:
    return True
else:
    return False",Give me the code to see if the design has any clock nets using OpenROAD Python API
"# Get the IoType of the MTerms of the instance 'split22'

# Get the design block
block = design.getBlock()

# Find the instance with name 'split22'
inst = block.findInst('split22')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",get the IoType of the mterms of the instance 'split22' using OpenROAD Python API
"# Get the IoType of the MTerms of the instance 'split22'

# Get the design block
block = design.getBlock()

# Find the instance with name 'split22'
inst = block.findInst('split22')

# Get the MTerms of the master cell
mterms = inst.getMaster().getMTerms()

# Initialize a dictionary to store IoTypes
iotype_dict = {}

# Iterate through all MTerms
for term in mterms:
    # Store the IoType of each term in the dictionary
    iotype_dict[term.getName()] = term.getIoType()

# Return the dictionary containing IoTypes
return iotype_dict",How can I get the IoType of the mterms of the instance 'split22' using OpenROAD Python API?
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store pin names
pin_name_list = []
# Loop through all instances
for inst in insts:
    # Get the pins of this instance
    inst_ITerms = inst.getITerms()
    # Loop through all pins
    for ITerm in inst_ITerms:
        # Append pin names to the list
        pin_name_list.append(design.getITermName(ITerm))
return pin_name_list",How can I put the name of every pin into a list?
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store pin names
pin_name_list = []
# Loop through all instances
for inst in insts:
    # Get the pins of this instance
    inst_ITerms = inst.getITerms()
    # Loop through all pins
    for ITerm in inst_ITerms:
        # Append pin names to the list
        pin_name_list.append(design.getITermName(ITerm))
return pin_name_list",Show me how to put every pin's name into a list
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store the name of the instance and its bottom-left corner and top-right corner's location
inst_name_location_list = []
# Loop through all instances
for inst in insts:
    # Get the properties
    cell_name = inst.getName()
    BBox = inst.getBBox()
    inst_x0 = BBox.xMin()
    inst_y0 = BBox.yMin()
    inst_x1 = BBox.xMax()
    inst_y1 = BBox.yMax()
    inst_name_location_list.append([cell_name, inst_x0, inst_y0, inst_x1, inst_y1])
return inst_name_location_list",Get the bounding box of all instances
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store the name of the instance and its bottom-left corner and top-right corner's location
inst_name_location_list = []
# Loop through all instances
for inst in insts:
    # Get the properties
    cell_name = inst.getName()
    BBox = inst.getBBox()
    inst_x0 = BBox.xMin()
    inst_y0 = BBox.yMin()
    inst_x1 = BBox.xMax()
    inst_y1 = BBox.yMax()
    inst_name_location_list.append([cell_name, inst_x0, inst_y0, inst_x1, inst_y1])
return inst_name_location_list","How to get a list of lists, with each inner list containing the name, the bottom-left corner, and the top-right corner locations of each instance?"
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store the name of the instance and its bottom-left corner and top-right corner's location
inst_name_location_list = []
# Loop through all instances
for inst in insts:
    # Get the properties
    cell_name = inst.getName()
    BBox = inst.getBBox()
    inst_x0 = BBox.xMin()
    inst_y0 = BBox.yMin()
    inst_x1 = BBox.xMax()
    inst_y1 = BBox.yMax()
    inst_name_location_list.append([cell_name, inst_x0, inst_y0, inst_x1, inst_y1])
return inst_name_location_list","Show me how I can get a list of lists, with each inner list containing the name, the bottom-left corner, and the top-right corner locations of each instance."
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create an empty list to store all cell_name-library_cell_name pair
inst_name_libcell_list = []
# Loop through all instances
for inst in insts:
    # Get the name of the cell
    cell_name = inst.getName()
    # Get the master of this instance
    master_cell = inst.getMaster()
    # Get the master name (library cell name) of this instance
    master_name = master_cell.getName()
    # Append them into a list
    inst_name_libcell_list.append([cell_name, master_name])
return inst_name_libcell_list",Get the liberty cell type for all instance
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create an empty list to store all cell_name-library_cell_name pair
inst_name_libcell_list = []
# Loop through all instances
for inst in insts:
    # Get the name of the cell
    cell_name = inst.getName()
    # Get the master of this instance
    master_cell = inst.getMaster()
    # Get the master name (library cell name) of this instance
    master_name = master_cell.getName()
    # Append them into a list
    inst_name_libcell_list.append([cell_name, master_name])
return inst_name_libcell_list",Show me how I can get the liberty cell type for all instance in a list
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create a list to store the result
inst_name_macro_list = []
# Loop through all instances
for inst in insts:
        # Get the name of the cell
        cell_name = inst.getName()
        # Get the master of this cell
        master_cell = inst.getMaster()
        # Check is the cell is a macro
        is_macro = 1 if master_cell.isBlock() else 0
        # Append the result
        inst_name_macro_list.append([cell_name, is_macro])
return inst_name_macro_list",check if an instance is a macro in the design
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create an empty list to store all cell_name-library_cell_name pair
inst_name_libcell_list = []
# Loop through all instances
for inst in insts:
    # Get the name of the cell
    cell_name = inst.getName()
    # Get the master of this instance
    master_cell = inst.getMaster()
    # Get the master name (library cell name) of this instance
    master_name = master_cell.getName()
    # Append them into a list
    inst_name_libcell_list.append([cell_name, master_name])
return inst_name_libcell_list",How can I get the liberty cell type for all instance in a list?
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create a list to store the result
inst_name_macro_list = []
# Loop through all instances
for inst in insts:
        # Get the name of the cell
        cell_name = inst.getName()
        # Get the master of this cell
        master_cell = inst.getMaster()
        # Check is the cell is a macro
        is_macro = 1 if master_cell.isBlock() else 0
        # Append the result
        inst_name_macro_list.append([cell_name, is_macro])
return inst_name_macro_list",How can I identify if a cell is a macro?
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create a list to store the result
inst_name_macro_list = []
# Loop through all instances
for inst in insts:
        # Get the name of the cell
        cell_name = inst.getName()
        # Get the master of this cell
        master_cell = inst.getMaster()
        # Check is the cell is a macro
        is_macro = 1 if master_cell.isBlock() else 0
        # Append the result
        inst_name_macro_list.append([cell_name, is_macro])
return inst_name_macro_list","Write a script to separate standard cells and macros in the design, show the result in a list."
"# Get the design block
block = ord.get_db_block()
# Get every instance
insts = block.getInsts()
# Create a list to store the result
pin_name_location_list = []
# Loop through all instances
for inst in insts:
    # Get all pins of this cell
    inst_ITerms = inst.getITerms()
    # Loop through all pins
    for ITerm in inst_ITerms:
        # Get the pin's name defines in  the lef file through MTerm
        MTerm_name = inst_ITerm.getMTerm().getName()
        # Get the name of the cell this pin belongs to.
        inst_name = inst_ITerm.getInst().getName()
        # Concat the two strings
        pin_name = ""{}/{}"".format(inst_name, MTerm_name)
        # Get the location of the pin in the layout
        pin_loc = ITerm.getAvgXY()
        if pin_loc[0]:
            pin_name_location_list.append([pin_name, pin_loc[0], pin_loc[1]])
        else:
            pin_name_location_list.append([pin_name, -1, -1])
return pin_name_location_list",Get the location of all pins
"# Get the DB
db = ord.get_db()
# Get all libraries read into the DB
libs = db.getLibs()
# Create a list to store every library cell's name
libcell_name_list = []
# Loop through all libraries
for lib in libs:
    # Get all library cells in this library
    lib_masters = lib.getMasters()
    # Loop through all library cells
    for master in lib_masters:
        # Get the name and append it to the list
        libcell_name = master.getName()
        libcell_name_list.append(libcell_name)
return libcell_name_list",Get the name of every liberty cell
