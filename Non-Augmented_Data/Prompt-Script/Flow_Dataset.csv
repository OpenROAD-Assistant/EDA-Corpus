code,prompt
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a gate-level netlist with a clock port called ""clk_i"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the standard cells and the macros. Place each macro at least 5 um away from each other, and set a halo region around each macro as 5 um. Set the number of iteration of the global router as 30. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a gate-level netlist with a clock port called ""clk_i"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. During detailed placement, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(40)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(55), design.micronToDBU(35)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,40. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 55,35. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a gate-level netlist with a clock port called ""clk"", read the tech file, lef files, and library files, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the standard cells and the macros. Place each macro at least 5 um away from each other, and set a halo region around each macro as 5 um. Set the number of iteration of the global router as 30. During detailed placement, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 1 
floorplan_aspect_ratio = 1 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 50%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform CTS with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 10 
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 10 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform CTS with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the standard cells and the macros. Place each macro at least 5 um away from each other, and set a halo region around each macro as 5 um. Set the number of iteration of the global router as 10. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the standard cells and the macros. Place each macro at least 5 um away from each other, and set a halo region around each macro as 5 um. Set the number of iteration of the global router as 10. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(40)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(55), design.micronToDBU(35)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,40. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 55,35. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(40)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(55), design.micronToDBU(35)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,40. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 55,35. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform CTS with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(15, 30, 10, 40)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 15 um,10 um, and the top-right corner as 30 um,40 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(40)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(55), design.micronToDBU(35)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,40. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 55,35. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After placement, do CTS and use BUF_X3 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 40 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(40), design.micronToDBU(60)) 
core_area = odb.Rect(design.micronToDBU(10), design.micronToDBU(10),  
  design.micronToDBU(30), design.micronToDBU(50)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 40,60. Set the bottom-left corner of the core's bounding box as 10,10 and the top-right corner as 30,50. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 20 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform CTS with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 50 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(70), design.micronToDBU(70)) 
core_area = odb.Rect(design.micronToDBU(6), design.micronToDBU(6),  
  design.micronToDBU(64), design.micronToDBU(64)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 20 times
gpl.setInitialPlaceMaxIter(20)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_spacing = [design.micronToDBU(4), design.micronToDBU(4)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 50 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 70,70. Set the bottom-left corner of the core's bounding box as 6,6 and the top-right corner as 64,64. After floorplanning, place the standard cells and the macros. Place each macro at least 5 um away from each other, and set a halo region around each macro as 5 um. Set the number of iteration of the global router as 20. During detailed placement, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 4 and 4 um, and for the power rings on M8, set the width and spacing to 4 and 4 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(50)) 
core_area = odb.Rect(design.micronToDBU(8), design.micronToDBU(8),  
  design.micronToDBU(52), design.micronToDBU(42)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a placed design with a clk port called ""clk_i"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,50. Set the bottom-left corner of the core's bounding box as 8,8 and the top-right corner as 52,42. After floorplanning, place the macros and the standard cells. Make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M6. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 45% 
floorplan_utilization = 45 
# Set the aspect ratio of the design (height/width) as 1.5 
floorplan_aspect_ratio = 1.5 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(32, 55, 32, 60)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M2""))

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk_i"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 45%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 32 um,32 um, and the top-right corner as 55 um,60 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform clock tree synthesis with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M6. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile make sure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 14 
floorplan_core_spacing = [design.micronToDBU(14) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 14 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as1. After the placement stage, perform CTS with using BUF_X3 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.0435 and 0.0817, respectively. Then construct PDN with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 2 um and set the spacing to 2 um. And if there are parallel grids, set the pitch of the via between two grids to 2 um. Last, set the offset to 0 for all cases. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 60% 
floorplan_utilization = 60 
# Set the aspect ratio of the design (height/width) as 1.3 
floorplan_aspect_ratio = 1.3 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
macro_ring_connect_to_pad_layers = [l for l in design.getTech().getDB().getTech().getLayers() if l.getType() == ""ROUTING""]
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = macro_ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""PDN.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 60%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. During detailed placement, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After placement, do CTS and use BUF_X2 as clock buffers, then set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power rings and power grids for macros on M5 and M6 , set the width and spacing of both the M5 and the M6 grids to 1.2 um, and set the pitch to 6 um. For the power ring on M5 and M6, set the width to 1.5 um and set the spacing to 1.5 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After PDN construction, get the IR drop analysis result on M1 layer and dump the def file and name it ""PDN.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 5 
floorplan_core_spacing = [design.micronToDBU(5) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 5 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, dump the def file and name it ""placement.def"". "
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In the end, dump the def file and name it ""final.def""."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 40% 
floorplan_utilization = 40 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

design.writeDef(""floorplan_place_pins.def"")

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

design.writeDef(""global_placement.def"")

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(18, 43, 12, 42)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

design.writeDef(""macro_placement.def"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""detailed_placement.def"")

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""cts.def"")

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

design.writeDef(""filler_placement.def"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

design.writeDef(""PDN.def"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

# Report Power

design.evalTclString(""report_power"")

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

design.writeDef(""final.def"")

","Given a synthesized netlist with a clock port named ""clk"", read the library and set the clock period as 20 ns. Then, perform floorplanning and set the target utilization as 40%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 18 um,12 um, and the top-right corner as 43 um,42 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. After constructing power grids, perform IR drop analysis on M1 nodes of the power grids. And report the switching, leakage, internal, and total power of the design. In the routing stage, route the design from M1 to M7. In each stage, dump the def file and name it according to the stage."
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 40 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(0.5) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a verilog-described netlist with a clk port called ""clk"", read the tech files and cell library information and set the clock period as 40 ns. Then, perform floorplanning and set the target utilization as 35%, and set the spacing between core and die as 12 microns. After that, place the pins on M8 and M9. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 30 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0.5 um, and the y-axis as0.5. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 5 and 5 um, and for the power rings on M8, set the width and spacing to 5 and 5 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"# Disconnect the nets of the instance 'input1' from the RC network

# Get the design block
block = design.getBlock()

# Find the instance with name 'input1'
inst = block.findInst('input1')

# Get the pins of the instance
pins = inst.getITerms()

# Iterate through the pins
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    if net:
        # Set the RC disconnected flag for the net
        net.setRCDisconnected(True)
",Disconnect the nets of the instance 'input1' from the RC network
"from openroad import Design, Tech

tech = Tech()
# Make sure to read all required files
design = Design(tech)
# Get PDNGen module
pdngen_obj = design.getPdnGen()
# Find the VDD net
VSS_net = design.getBlock().findNet(""VSS"")
# Rip up the VSS grids
pdn_obj.ripUp(VSS_net)",Rip up the VSS grids
"from openroad import Tech, Design

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(118)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M6 and M7
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M6""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M7""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)",How can I place I/O pins of the design block on M6 and M7 layers?
"from openroad import Tech, Design

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")
# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()",How can I perform global placement?
"from openroad import Tech, Design

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Global Placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 30 times
gpl.setInitialPlaceMaxIter(30)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement
# In OpenROAD, global placement should be performed before macro placement
macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Place the macros using the entire core area
  core = design.getBlock().getCoreArea()
  units = design.getBlock().getDbUnitsPerMicron()
  core_lx = core.xMin() / units
  core_ly = core.yMin() / units
  core_ux = core.xMax() / units
  core_uy = core.yMax() / units
  design.getMacroPlacer().setFenceRegion(core_lx, core_ly, core_ux, core_uy)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()",Place the macros onto the design block
"from openroad import Tech, Design

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)",Perform detailed placement in OpenROAD
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Add Filler Cells
db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)",Add filler cells on the design block
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power distribution network
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m7, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()",Show me how I can construct power distribution network in OpenROAD
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_spacing = [design.micronToDBU(5), design.micronToDBU(5)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(2) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for core
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top_pdn"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top_pdn"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

# Create power delivery network for macros
# Set the width of the PDN ring for macros and the spacing between VDD and VSS rings for macros
macro_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6""
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""Macro_core_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""Macro_core_grid_"" + str(i))
  for g in grid:
    pdngen.makeRing(grid = g, layer0 = m5, width0 = macro_ring_width[0], spacing0 = macro_ring_spacing[0],
                    layer1 = m6, width1 = macro_ring_width[0], spacing1 = macro_ring_spacing[0],
                    starts_with = pdn.GRID, offset = macro_ring_core_offset, pad_offset = ring_pad_offset, extend = False,
                    pad_pin_layers = macro_ring_connect_to_pad_layers, nets = [])
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()",Show me how I can build power distribution network if my design has macros
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))",How can I perform IR drop analysis on the M1 layer where the pins are located?
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

design.evalTclString(""report_power"")","Report the switching power, internal power and leakage power of the design"
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Global Routing
signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M6"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)",Perform global routing in OpenROAD
"from openroad import Design, Tech
import openroad as ord

tech = Tech()
# Read the files into Openroad
design = Design(tech)

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 35% 
floorplan_utilization = 35 
# Set the aspect ratio of the design (height/width) as 0.5 
floorplan_aspect_ratio = 0.5 
# Set the spacing between core and die as 12 
floorplan_core_spacing = [design.micronToDBU(12) for i in range(4)] 
# Find the site in lef
db = ord.get_db()
libs = db.getLibs()
site_name = """"
for lib in libs:
  sites = lib.getSites()
  if len(sites) == 0:
    continue
  else:
    site_name = sites[0].getName()
    break    
site = floorplan.findSite(site_name)
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site)
floorplan.makeTracks()",How can I automatically search for the name of the site and use that for floorplanning?
"from openroad import Tech, Design
tech = Tech()
# Make sure you have .lef files read into OpenROAD DB
design = Design(tech)

design.evalTclString(""create_clock -period 50 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")","If the clock port is called clk_i, how can I set the design clock period to 50 nanoseconds?"
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
verilogFile = designDir/str(design_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk_i] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(45), design.micronToDBU(45)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(40), design.micronToDBU(40)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(5, 20, 5, 25)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMaxWl()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0) / site.getWidth())
max_disp_y = int(design.micronToDBU(0) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

design.writeDef(""placement.def"")

","Given a synthesized netlist with a clock port named ""clk_i"", read the library and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 45,45. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 40,40. After floorplanning, place the macros and the standard cells. Place the macros with a bounding box with the bottom-left corner as 5 um,5 um, and the top-right corner as 20 um,25 um. And place each macro at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 0 um, and the y-axis as0. After the placement stage, dump the def file and name it ""placement.def"". "
"from openroad import Tech, Design
tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Clock Tree Synthesis
design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.0435 -capacitance 0.0817"")
design.evalTclString(""set_wire_rc -signal -resistance 0.0435 -capacitance 0.0817"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X3"")
cts.setRootBuffer(""BUF_X3"")
cts.setSinkBuffer(""BUF_X3"")
cts.runTritonCts()

# Detailed Placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(0.5) / site.getWidth())
max_disp_y = int(design.micronToDBU(1) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)",Show me how I can perform CTS in OpenROAD
"from openroad import Tech, Design
import openroad as ord

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)
design.readDb(""xxx.odb"")

# Detailed Routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M6""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()",Perform detailed routing in OpenROAD
"from openroad import Tech, Design
from pathlib import Path

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
libFiles = libDir.glob(""*.lib"")
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
design = Design(tech)",How can I read .lib files into OpenROAD?
"from openroad import Tech, Design
from pathlib import Path

tech = Tech()
# Set file path
lefDir = Path(""lef_path"")
lefFiles = lefDir.glob('*.lef')
# Modify the technology file postfix for other naming convention
techLefFiles = lefDir.glob(""*.tech.lef"")
# Read library files
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)",How can I read .lef files into OpenROAD?
"from openroad import Tech, Design
from pathlib import Path

tech = Tech()
# Make sure you have .lef files read into OpenROAD DB
design = Design(tech)

designDir = Path(""design_path"")
design_file_name = ""design_filename""
design_top_module_name = ""design_top_module_name""
verilogFile = designDir/str(design_file_name + "".v"")
design.readVerilog(""verilogFile"")
design.link(design_top_module_name)",Show me the way to read the Verilog file into OpenROAD
"from openroad import Design, Tech

tech = Tech()
# Make sure to read all required files
design = Design(tech)
# Get PDNGen module
pdngen_obj = design.getPdnGen()
# Find the VDD net
VDD_net = design.getBlock().findNet(""VDD"")
# Rip up the VDD grids
pdn_obj.ripUp(VDD_net)",Rip up the VDD grids
"import openroad as ord
from openroad import Tech, Design
import os, odb, drt, pdn, re
from pathlib import Path

# Read Files

tech = Tech()
# Set file path
libDir = Path(""lib_path"")
lefDir = Path(""lef_path"")
techlefDir = Path(""techlef_path"")
designDir = Path(""design_path"")

design_name = ""design_filename""
design_top_module_name = ""design_top_module_name""

libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')
# Read library files
for libFile in libFiles:
  tech.readLiberty(libFile.as_posix())
for techLefFile in techLefFiles:
  tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
  tech.readLef(lefFile.as_posix())
design = Design(tech)
# Read design files
defFile = designDir/str(design_name + "".def"")
design.readDef(""defFile"")

# Set the clocks
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [all_clocks]"")
# Floorplanning 

floorplan = design.getFloorplan() 
# Set the core and die area 
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
  design.micronToDBU(60), design.micronToDBU(40)) 
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
  design.micronToDBU(55), design.micronToDBU(35)) 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(die_area, core_area, site) 
floorplan.makeTracks()

# Place Pins

params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place the pins on M8 and M9
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""M8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""M9""))
IOPlacer_random_mode = True
design.getIOPlacer().run(IOPlacer_random_mode)

# Global Placement

gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Set the max iteration of global placement to 10 times
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace()
gpl.doNesterovPlace()
gpl.reset()

# Macro Placement

macros = [inst for inst in ord.get_db_block().getInsts() if inst.getMaster().isBlock()] 
if len(macros) > 0:
  mpl = design.getMacroPlacer()
  # Set the halo around macros to 5 microns
  mpl_halo_x, mpl_halo_y = 5, 5
  mpl.setHalo(mpl_halo_x, mpl_halo_y)
  # Set the channel width between macros to 5 microns
  mpl_channel_x, mpl_channel_y = 5, 5
  mpl.setChannel(mpl_channel_x, mpl_channel_y)
  # Set the fence region as a user defined area in microns
  design.getMacroPlacer().setFenceRegion(30, 55, 15, 35)
  # Snap the macro to layer M4 (usually M4)
  layer = design.getTech().getDB().getTech().findLayer(""M4"")
  mpl.setSnapLayer(layer)
  mpl.placeMacrosCornerMinWL()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Clock Tree Synthesis

design.evalTclString(""set_propagated_clock [core_clock]"")
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")

cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Can choose different buffer cells for cts
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Detailed Placement

site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Add Filler Cells

db = ord.get_db()
filler_masters = list()
# Filler cell prefix may be different when using different library
filler_cells_prefix = ""filler_.*""
for lib in db.getLibs():
  for master in lib.getMasters():
    master_name = master.getConstName()
    if re.fullmatch(filler_cells_prefix, master_name) != None:
      filler_masters.append(master)
if len(filler_masters) == 0:
  print(""wrong filler cell prefix"")
else:
  design.getOpendp().fillerPlacement(filler_masters, filler_cells_prefix)

# Power Planning

# Global Connect
for net in design.getBlock().getNets():
  if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
    net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
if VDD_net == None:
  VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
  VDD_net.setSpecial()
  VDD_net.setSigType(""POWER"")
if VSS_net == None:
  VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
  VSS_net.setSpecial()
  VSS_net.setSigType(""GROUND"")
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"", 
                                  pinPattern = ""^VDD$"", net = VDD_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDPE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VDDCE$"", net = VDD_net,
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSS$"", net = VSS_net, 
                                  do_connect = True)
design.getBlock().addGlobalConnect(region = None, instPattern = "".*"",
                                  pinPattern = ""^VSSE$"", net = VSS_net,
                                  do_connect = True)
design.getBlock().globalConnect()
# Voltage Domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net, switched_power = switched_power, 
                    ground = VSS_net, secondary = secondary)
# Set the width of the PDN ring and the spacing between VDD and VSS rings
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# When the two layers are parallel, specify the distance between via cuts.
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
  if layer.getType() == ""ROUTING"":
    ring_connect_to_pad_layers.append(layer)

# Define power grid for std cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
  pdngen.makeCoreGrid(domain = domain, name = ""top"", starts_with = pdn.GROUND, 
                      pin_layers = [], generate_obstructions = [], powercell = None,
                      powercontrol = None, powercontrolnetwork = ""STAR"")
m1 = design.getTech().getDB().getTech().findLayer(""M1"")
m4 = design.getTech().getDB().getTech().findLayer(""M4"")
m7 = design.getTech().getDB().getTech().findLayer(""M7"")
m8 = design.getTech().getDB().getTech().findLayer(""M8"")
grid = pdngen.findGrid(""top"")
for g in grid:
  # Make Ring for the core
  pdngen.makeRing(grid = g, layer0 = m7, width0 = core_ring_width[0], spacing0 = core_ring_spacing[0],
                  layer1 = m8, width1 = core_ring_width[0], spacing1 = core_ring_spacing[0],
                  starts_with = pdn.GRID, offset = core_ring_core_offset, pad_offset = core_ring_pad_offset, extend = False,
                  pad_pin_layers = ring_connect_to_pad_layers, nets = [])
  # Add power and ground grid on M1 and attach to cell/macro's VDD/VSS pin
  pdngen.makeFollowpin(grid = g, layer = m1, 
                      width = design.micronToDBU(0.07), extend = pdn.CORE)
  # Create the rest of the power delivery network
  pdngen.makeStrap(grid = g, layer = m4, width = design.micronToDBU(1.2), 
                  spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0), 
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
  pdngen.makeStrap(grid = g, layer = m7, width = design.micronToDBU(1.4),
                  spacing = design.micronToDBU(1.4), pitch = design.micronToDBU(10.8), offset = design.micronToDBU(0),
                  number_of_straps = 0, snap = False, starts_with = pdn.GRID, extend = pdn.RINGS, nets = [])
  pdngen.makeConnect(grid = g, layer0 = m1, layer1 = m4, 
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m7,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
  pdngen.makeConnect(grid = g, layer0 = m7, layer1 = m8,
                  cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                  max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
# Create power delivery network for macros
m5 = design.getTech().getDB().getTech().findLayer(""M5"")
m6 = design.getTech().getDB().getTech().findLayer(""M6"")
for i in range(len(macros)):
  for domain in domains:
    pdngen.makeInstanceGrid(domain = domain, name = ""CORE_macro_grid_"" + str(i),
                            starts_with = pdn.GROUND, inst = macros[i], halo = halo,
                            pg_pins_to_boundary = True, default_grid = False, 
                            generate_obstructions = [], is_bump = False)
  grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
  for g in grid:
    pdngen.makeStrap(grid = g, layer = m5, width = design.micronToDBU(1.2), 
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeStrap(grid = g, layer = m6, width = design.micronToDBU(1.2),
                    spacing = design.micronToDBU(1.2), pitch = design.micronToDBU(6), offset = design.micronToDBU(0),
                    number_of_straps = 0, snap = True, starts_with = pdn.GRID, extend = pdn.CORE, nets = [])
    pdngen.makeConnect(grid = g, layer0 = m4, layer1 = m5,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m5, layer1 = m6,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )
    pdngen.makeConnect(grid = g, layer0 = m6, layer1 = m7,
                    cut_pitch_x = pdn_cut_pitch[0], cut_pitch_y = pdn_cut_pitch[1], vias = [], techvias = [],
                    max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = )

pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Global Routing

signal_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""M1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""M7"").getRoutingLevel()
grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Detailed Routing

drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""M1""
params.topRoutingLayer = ""M7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Static IR drop Analysis

psm_obj = design.getPDNSim()
psm_obj.setNet(ord.Tech().getDB().getChip().getBlock().findNet(""VDD""))
design.evalTclString(f""psm::set_corner [sta::cmd_corner]"")
psm_obj.analyzePowerGrid('', False, '', '')
drops = psm_obj.getIRDropForLayer(tech.getDB().getTech().findLayer(""M1""))

design.writeDef(""final.def"")

","Given a placed design with a clk port called ""clk"", read the technology file and cell libraries, and set the clock period as 20 ns. Perform floorplan and set the bottom-left location of the bounding box of the die as 0,0 and the top-right corner as 60,40. Set the bottom-left corner of the core's bounding box as 5,5 and the top-right corner as 55,35. After floorplanning, place the macros and the standard cells. Set a fence region to place macros inside the bounding box with the bottom-left corner as 30 um,15 um, and the top-right corner as 55 um,35 um. Meanwhile ensure each macro is at least 5 um to each other, and set a halo region around each macro as 5 um. Set the iteration of the global router as 10 times. In the detailed placement stage, set the maximum displacement at the x-axis as 1 um, and the y-axis as3. After the placement stage, perform clock tree synthesis with using BUF_X2 as clock buffers, and set the unit resistance and the unit capacitance value for clock and signal wires to 0.03574 and 0.07516, respectively. Then construct a power grid with power rings on M7 and M8, and have power grids on M1 and M4 for standard cells and macros respectively. Set the width of the M1 grid as 0.07 um, and the width of the M4 grid is 1.2 um. Set the spacing of the M4 grid as 1.2 um and the pitch of the M4 power grid as 6 um. Set the width of the power grids on M7 to 1.4 um and set the spacing and the pitch to 1.4 um and 10.8 um. For the power rings on M7, set the width and spacing to 2 and 2 um, and for the power rings on M8, set the width and spacing to 2 and 2 um as well. If the design has macros, build power grids for macros on M5 and M6 , set the width and spacing of both M5 and M6 grids to 1.2 um, and set the pitch to 6 um. And if there are parallel grids, set the pitch of the via between two grids to 0 um. Last, set the offset to 0 for all cases. In the routing stage, route the design from M1 to M7. In the end, perform IR drop analysis on M1 and dump the def file and name it ""final.def""."
"def check_annealing_debug_and_print_config():
    # Get the IO Placer object of the design
    io_placer = design.getIOPlacer()

    # Print the configurations of the IO placer
    io_placer.printConfig()

    # Return whether the annealing debug is on
    return io_placer.isAnnealingDebugOn()

# Call the function to check the annealing debug mode and print the config
annealing_debug_on = check_annealing_debug_and_print_config()",Check if the annealing debug mode is on for the IO pin placer and print the configs of the IO pin placer
"# Get the defined top layer of the IO pin placer

# Get the IO Placer object of the design
iop = design.getIOPlacer()

# Return the top layer
topLayer = iop.getTopLayer()",Get the defined top layer of the IO pin placer
"def set_min_distance_if_zero(min_distance_value):
    # Get the IO Placer object of the design
    iop = design.getIOPlacer()

    # Get the parameters of the IO Placer
    parameters = iop.getParameters()

    # Get the minimum distance
    min_dist = parameters.getMinDistance()

    # Set the minimum distance to 100 if it is 0
    if min_dist == 0:
        parameters.setMinDistance(min_distance_value)

    # Set min distance in tracks
    parameters.setMinDistanceInTracks(True)

    return min_dist

# Call the function with the hard-coded min distance value 100
min_distance = set_min_distance_if_zero(100)",Get the minimum distance setting of the IO pin placer and set it to 100 if it is 0
"# Get the number of DRVs, cloud size and set the could size to 500 from the detailed router

# Get the Triton Route object of the design
triton_route = design.getTritonRoute()

# Get the number of DRVs
num_drvs = triton_route.getNumDRVs()

# Set the cloud size to 500
cloud_size = triton_route.setCloudSize(500)def get_and_set_drv_and_cloud_size(cloud_size_value):
    # Get the Triton Route object of the design
    triton_route = design.getTritonRoute()

    # Get the number of DRVs
    num_drvs = triton_route.getNumDRVs()

    # Set the cloud size to the specified value
    cloud_size = triton_route.setCloudSize(cloud_size_value)

    # Return the number of DRVs and cloud size
    return (num_drvs, cloud_size)

# Call the function with the hard-coded cloud size value of 500
drv_and_cloud_size = get_and_set_drv_and_cloud_size(500)

# Return the number of DRVs and cloud size
return (num_drvs, cloud_size)","Get the number of DRVs, cloud size and set the could size to 500 from the detailed router"
"# Change the setting of horizontal and vertical length of thr IO pin placer to 100

# Get the IO Placer object of the design
iop = design.getIOPlacer()

# Get the parameters of the IO Placer
parameters = iop.getParameters()

# Set vertical and horizontal length to 100
parameters.setVerticalLength(100)
parameters.setHorizontalLength(100)",Change the setting of horizontal and vertical length of thr IO pin placer to 100
"# Adjust the setting of vertical length of the IO pin placer to 100

# Get the IO Placer object of the design
iop = design.getIOPlacer()

# Get the parameters of the IO Placer
parameters = iop.getParameters()

# Set vertical length to 100
parameters.setVerticalLength(100)",Adjust the setting of vertical length of the IO pin placer to 100