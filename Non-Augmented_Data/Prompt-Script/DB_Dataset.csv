code,prompt
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input2' as mentioned in the prompt
inst = block.findInst('input2')
#Set the location to coordinates (22500, 33459)
inst.setLocation(22500,33459)","Set the location of the instance named 'input2' to coordinates (22500, 33459)."
"# Get the design block 
block = design.getBlock()

# Find the instance named ""output52""
inst = block.findInst(""output52"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Print the net name
        print(""Net:"", net.getName())
        
        # Print the wire opcodes
        net.printWire()",Print the wire opcode information of the the nets connecting to the instance output52
"def get_metal_layers_and_io_top_layer(layer_name):
    # Get the current block of the design
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Find the specified layer in the technology
    layer = tech.findLayer(layer_name)

    # Get the upper and lower layers of the specified layer
    upper_lower_layer = {
        ""upper"": layer.getUpperLayer(),
        ""lower"": layer.getLowerLayer()
    }

    # Get the top layer of the IO Placer object of the design
    iop = design.getIOPlacer()
    iop_top_layer = iop.getTopLayer()

    # Return a tuple containing the upper and lower layer of the specified layer and the top layer used for the IO pin placer
    return (upper_lower_layer, iop_top_layer)

# Call the function with ""metal5"" as the argument
metal5_layers_info = get_metal_layers_and_io_top_layer(""metal5"")","Retrieve the upper and lower layers of the 'metal5' layer and encapsulate them in a dictionary with ""upper"" and ""lower"" as keys. Additionally, retrieve the setting of the top layer used for the IO pin placer. Return the results as a tuple."
"# Vertically flip the rotation of the instances whose library cell types are 'AND2_X1'

#define flipping function
def flipY(value):
    if value == ""R0"":
      return ""MY""
    elif value == ""R90"":
      return ""MXR90""
    elif value == ""R180"":
      return ""MX""
    elif value == ""R270"":
      return ""MYR90""
    elif value == ""MY"":
      return ""R0""
    elif value == ""MYR90"":
      return ""R270""
    elif value == ""MX"":
      return ""R180""
    elif value == ""MXR90"":
      return ""R90""

# Get the design block
block = design.getBlock()

# Get all instances in the block
insts = block.getInsts()

# Iterate through all instances in the block
for inst in insts:
    # Check if the library cell type is 'NAND2_X1'
    if inst.getMaster().getName() == 'NAND2_X1':
        # Vertically flip the rotation of the instance
        transform = inst.getTransform()
        orient = transform.getOrient()
        orient = flipY(orient)
        inst.setOrient(orient)",Vertically flip the rotation of the instances whose library cell types are 'NAND2_X1'
"# Set the rotation of the instance '_411_' to 'MX'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Set the rotation of the instance to 'MX'
inst.setOrient('MX')",set the rotation of the instance '_411_' to 'MX'
"# Get the design block
block = ord.get_db_block()
# Get the database
db = ord.get_db()
# Get all nets
nets = block.getNets()
# Find the POWER and GROUND nets
for net in nets:
    if net.getSigType() == 'POWER':
        power_net = net
    elif net.getSigType() == 'GROUND':
        ground_net = net
# Find the source instance named ""_350_""
source_inst = block.findInst(""_350_"")
# Find the pin connected to net ""_036_""
for pin in source_inst.getITerms():
    if pin.getNet() is not None:
        if pin.getNet().getName() == '_036_':
            source_pin = pin
            source_net = pin.getNet()
            break
# Create a new net
new_net = odb.dbNet_create(block,'new_net_1')
# Find the master instance named 'BUF_X2'
mast = db.findMaster('BUF_X2')
# Create a new instance named 'new_inst_1' using the 'BUF_X2' master
new_inst = odb.dbInst_create(block,mast,'new_inst_1')
# Disconnect the source pin
source_pin.disconnect()
# Connect the source pin to the new net
source_pin.connect(new_net)
# Connect the pins of the new instance
for pin in new_inst.getITerms():
    if pin.isInputSignal():
        pin.connect(new_net)
    elif pin.isOutputSignal():
        pin.connect(source_net)
    elif pin.getSigType() == 'POWER':
        pin.connect(power_net)
    elif pin.getSigType() == 'GROUND':
        pin.connect(ground_net)
","Add a new instance 'new_inst_1' using buffer cell BUF_X2 after the instance '_350_' on the net '_036', and connect the instances using a new net 'new_net_1'"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm('req_val')
# Disconnect the port
port.disconnect()",Disconnect the port named 'req_val' from the nets it is connected to
"# Get the current design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# Dictionary to store Capacitance Coupling Match Ratio of each net
net_cc_match_ratio = {}

# Iterate through each net and store its Capacitance Coupling Match Ratio
for net in nets:
    net_cc_match_ratio[net.getName()] = net.getCcMatchRatio()

# List of net names to set Capacitance Coupling Match Ratio to 1
nets = [""req_msg[13]"", ""clk""]

# Iterate through each net name in the list and set its Capacitance Coupling Match Ratio to 1
for net_name in nets:
    net = block.findNet(net_name)
    net.setCcMatchRatio(1)","Calculate the Capacitance Coupling Match Ratio for each net and organize the results into a dictionary. Use the net names as keys and their corresponding Capacitance Coupling Match Ratios as values. Additionally, ensure that the Capacitance Coupling Match Ratios for the nets named ""req_msg[13]"" and ""clk"" are set to 1."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the vias defined in the technology
vias = tech.getVias()

# Get the Via Count of the technology
via_count = tech.getViaCount()

# Set the Clearance Measure of the technology to 500
print(tech.getClearanceMeasure())

# Create a dictionary containing vias and the count of vias
result = {
    ""vias"": vias,
    ""count"": via_count
}","Get the vias and via count as a dictionary with ""vias"" and ""count"" as keys, and print the Clearance Measure."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology file
layers = tech.getLayers()

# Dictionary to store areas of layers with their names
layer_area_dict = {}

# Iterate through each layer
for layer in layers:
    # Store the area of the layer with its name in the dictionary
    layer_area_dict[layer.getName()] = layer.getArea()

# Create a result dictionary containing layer area dictionary and list of layer names
result = {
    ""area_dict"": layer_area_dict,
    ""layer_names"": list(layer_area_dict.keys())
}","Retrieve the layer names defined in the technology as a list and obtain the corresponding areas of these layers of the technology, associating each area with its respective layer name in a dictionary. Return this result encapsulated in a dictionary with ""area_dict"" representing the areas of the layers and ""layer_names"" representing the list of layer names."
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the Via Count of the technology
via_count = tech.getViaCount()

# Get the Via Generate Rules of the technology
via_rules = tech.getViaGenerateRules()

# Get the current value of database units per micron and add 500
db_microns = block.getDbUnitsPerMicron() + 500

# Set the new value of database units per micron
tech.setDbUnitsPerMicron(db_microns)

# Create a dictionary containing via count, via rules, and the updated value of database units per micron
result = {
    ""count"": via_count,
    ""rules"": via_rules
}","Retrieve the via count and via generate rules of the technology. Return the result as a dictionary with ""count"" and ""rules"" as keys for the via count and via generate rules, respectively."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store rotation of the instances whose library cells are of type 'NOR2_X1'
NOR_transform_orient = {}

# Iterate through each instance
for inst in insts:
    # Check if the library cell name is ""NOR2_X1""
    if inst.getMaster().getName() == ""NOR2_X1"":
        # Store the rotation of the instance
        NOR_transform_orient[inst.getName()] = inst.getTransform().getOrient()
    
    # Check if the instance name is ""_411_"" or ""input1""
    if inst.getName() == ""_411_"" or inst.getName() == ""input1"":
        # Mark the first output net of the instance
        inst.getFirstOutput().getNet().setMark(True)","Get the rotation of the instances whose library cells are of type 'NOR2_X1' and return as a dict with instance name as keys, and mark the first output nets of the instances '_411_' and 'input1'."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through each instance
for inst in insts:
    # Check if the master cell name contains ""NAND2_X1""
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Invert the instance
        inst.getTransform().invert()
    
    # Check if the instance name is ""_411_"" or ""input1""
    if inst.getName() == ""_411_"" or inst.getName() == ""input1"":
        # Get the transform of the instance
        transform = inst.getTransform()
        # If the orientation is 'R0', set it to 'MX'; if 'MX', set it to 'R0'
        if transform.getOrient() == 'R0':
            transform.setOrient('MX')
        elif transform.getOrient() == 'MX':
            transform.setOrient('R0')",Invert the offset and the rotation of instances whose library cells are 'NAND2_X1' and set the orient of the instance '_411_' to 'R0' if 'MX' or 'MX' if 'R0'.
"# Get the current design block
block = design.getBlock()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Set the orientation of the instance '_411_' to 'MX'
inst.getTransform().setOrient('MX')

# Get all instances
insts = block.getInsts()

# Dictionary to store halos of instances
inst_halos = {}

# Iterate through each instance
for inst in insts:
    # Store the halo of the instance in the inst_halos dictionary
    inst_halos[inst.getName()] = inst.getHalo()",Set the orientation of the instance '_411_' to 'MX' and retrieve all the halos of instances. Return the result as a dictionary with each instance's name as the key mapped to their halo.
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Initialize lists to store non-core instances and vertical tech layers with capacitance
vertical_layers = []
non_core_insts = []

# Define the direction for the layers
direction = 'VERTICAL'

# Iterate through each instance
for inst in insts:
    # Check if instance is not core instance
    if not inst.getMaster().isCore():
        # Add the instance to the list of non-core instances
        non_core_insts.append(inst)

# Iterate through each layer in the technology
for layer in layers:
    # Check if the layer direction is VERTICAL
    if layer.getDirection() == direction:
        # Add the layer and its capacitance to the list of vertical layers
        vertical_layers.append((layer, layer.getCapacitance()))",Get a list of all the non-core instances and a list of the vertical layers and their capacitance as a list of tuples.
"def get_signal_types_and_endcap_status(target_instance_name, check_instance_name='_411_'):
    # Get the current design block
    block = design.getBlock()

    # Get all the instances
    insts = block.getInsts()

    # Find the instance with the name check_instance_name
    check_instance = block.findInst(check_instance_name)

    # Dictionary to store signal types in nets
    signal_type_dict = {}

    # Check if check_instance is of type ENDCAP or any of its subtypes
    endcap_status = check_instance.isEndCap()
    print(f""End cap status of cell '{check_instance_name}':"", endcap_status)

    # Loop through all instances
    for inst in insts:
        # Check if any of the user flags are set to true
        if inst.getUserFlag1() or inst.getUserFlag2() or inst.getUserFlag3():
            # Set the level of the instance to 1
            inst.setLevel(1)

        # Check if the instance name matches target_instance_name
        if inst.getName() == target_instance_name:
            # Get the nets connected to the target instance
            nets = [pin.getNet() for pin in inst.getITerms()]

            # Iterate through each net
            for net in nets:
                # Check if the net exists
                if net:
                    # Store the signal type of the net in the dictionary
                    signal_type_dict[net.getName()] = net.getSigType()
            break

    # Return the dictionary containing signal types in nets
    return signal_type_dict

# Call the function to get the signal types for 'input1' and check '_411_'
signal_types = get_signal_types_and_endcap_status('input1')","Check if the library cell of instance '_411_' is type ENDCAP and get all the instances whose user flags are set and set those instances to level 1, also get the signal types in the nets of instance 'input1'"
"# Set userFlags 1 and 3 true for instance '411' and retrieve the LEQ (Logic Equivalent) information associated with the library cell of instance '411'.

# Get the dsign block
block = design.getBlock()

# Find the instance '411'
inst = block.findInst(""_411_"")

# Set userFlags 1 and 3 true
inst.setUserFlag1()
inst.setUserFlag3()

# Get the library cell of instance '411'
master = inst.getMaster()

# Retrieve the LEQ information associated with the library cell
LEQ = master.getLEQ()",Set userFlags 1and 3 true for instance '411' and retrieves the LEQ (Logic Equivalent) information associated with the library cell of instance '411'.
"def get_and_nand_info():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Dictionary to store offsets of 'AND2_X1' instances
    offset_dict_AND = {}
    # Dictionary to store orientations of 'NAND2_X1' instances
    orient_dict_NAND = {}

    # Iterate through instances
    for inst in insts:
        # Check if the master cell name is 'AND2_X1'
        if inst.getMaster().getName() == ""AND2_X1"":
            # Get transform and store offset
            transform = inst.getTransform()
            offset_dict_AND[inst.getName()] = transform.getOffset()

        # Check if the master cell name is 'NAND2_X1'
        elif inst.getMaster().getName() == ""NAND2_X1"":
            # Get transform and store orientation
            transform = inst.getTransform()
            orient_dict_NAND[inst.getName()] = transform.getOrient()

    # Return dictionaries of offsets and orientations
    return offset_dict_AND, orient_dict_NAND

# Call the function to retrieve the information
and_offsets, nand_orientations = get_and_nand_info()",Get the location of the instances whose library cell is 'AND2_X1' as a dicitonary with instance names as keys and get rotation of instance whose library cells are of type 'NAND2_X1'.
"# Set all the COVER master cells to frozen

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through instances
for inst in insts:
    # Get the master of the instance
    master = inst.getMaster()        
    # Check if the master is of type COVER
    if master.isCover():
        # Set the COVER master cell to frozen so dbMTerms cannot be added or delete from the master
        master.setFrozen()",set all the COVER master cells to frozen
"def get_signal_nets_and_blockages():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # List to store nets with signal type 'SIGNAL'
    signal_nets = []

    # Iterate through instances
    for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate through pins
        for pin in pins:
            # Check if the signal type is 'SIGNAL'
            if pin.getSigType() == 'SIGNAL':
                # Add the net to the list
                signal_nets.append(pin.getNet())

    # Get all blockages in the block
    blockages = block.getBlockages()

    # Return a tuple containing the list of nets and blockages
    return (signal_nets, blockages)

# Call the function to retrieve the information
signal_nets, blockages = get_signal_nets_and_blockages()","Get a list of all the nets of the instances whose signal type is ""SIGNAL"" and get all the blockages. Return the result as a tuple"
"# Get the design block
block =design.getBlock()

# Reset the tapcell in the design
tapcell = design.getTapcell()
tapcell.reset()

# Retrieve the coupling capacitance segments
coupling_segments = block.getCCSegs()",Reset the tapcell in the design and retrieve the coupling capacitance segments of the design block.
"# Get the list of hierarchical filler cell instances.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# List to store hierarchical instances with filler cells
inst_list = []

# Iterate through instances
for inst in insts:
    # Check if the instance is hierarchical and its master is a filler cell
    if inst.isHierarchical() and inst.getMaster().isFiller():
        inst_list.append(inst)",Get the list of hierarchical filler cell instances.
"def get_resistor_segments_and_hybrid_rows():
    # Get the design block
    block = design.getBlock()

    # Retrieve resistor segments
    resistor_segments = block.getRSegs()

    # Get the sites of rows
    rows = block.getRows()
    hybrid_rows = {}
    
    # Iterate through rows to find hybrid sites
    for row in rows:
        if row.getSite().isHybrid():
            hybrid_rows[row] = row.getSite()

    # Return resistor segments and hybrid rows
    return (resistor_segments, hybrid_rows)

# Call the function to get the information
resistor_segments, hybrid_rows = get_resistor_segments_and_hybrid_rows()","Get the resistor segments and a dictionary of the hybrid sites of the rows, with the row as the key and the site as the value."
"# Get source type of all the instance on level 1 with filler cells and set the placement Status of the instance 'input1' to 'UNPLACED'.

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store source types
source_dict = {}

# Iterate through instances
for inst in insts:
    # Check if the instance's master is a filler cell and it is set as level 1
    if inst.getMaster().isFiller() and inst.getLevel() == 1:
        # Get and store the source type
        source_dict[inst.getName()] = inst.getSourceType()
    
    # Check if the instance is 'input1' and set its placement status to 'UNPLACED'
    if inst.getName() == ""input1"":
        inst.setPlacementStatus('UNPLACED')","Get source type of all the filler cell instances set as level 1 as a dictionary with inst name as keys. Also, set the placement status flag of the instance 'input1' to 'UNPLACED'."
"def set_layer_aliases_and_get_min_spacing():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the alias of each layer
    layer_alias = {}

    # Iterate through all layers
    for layer in layers:
        # Construct the alias using the layer index
        alias = ""LayerX"" + str(layer.getNumber())

        # Set the alias of the layer
        layer.setAlias(alias)

        # Store the alias of the layer in the dictionary
        layer_alias[layer.getName()] = alias

    # Get the status of USEMINSPACING for pins in LEF
    min_spacing_pin = tech.getUseMinSpacingPin()

    # Return the dictionary containing the updated alias of layers and min spacing status
    return {
        ""Alias"": layer_alias,
        ""min_spacing_pin"": min_spacing_pin
    }

# Call the function to get the results
results = set_layer_aliases_and_get_min_spacing()","Set the alias of the layers by the naming convention ''LayerXi"" where i is the index of the layer and get the status of USEMINSPACING for pins in LEF. return the results as a dict with each requirement as key names."
"def get_mterms_and_input_mterms(inst_name_1, inst_name_2):
    # Get the current block of the design
    block = design.getBlock()

    # Find the instances using the provided names
    inst1 = block.findInst(inst_name_1)
    inst2 = block.findInst(inst_name_2)

    # Get the library cells of the instances
    master1 = inst1.getMaster()
    master2 = inst2.getMaster()

    # Get the MTerms of the library cell of the instance inst_name_1
    mterms1 = master1.getMTerms()

    # Get the MTerms of the library cell of the instance inst_name_2
    mterms2 = master2.getMTerms()

    # List to store input MTerms of the instance inst_name_2
    input_mterms = []

    # Iterate through each MTerm of the instance inst_name_2
    for mterm in mterms2:
        # Check if the IoType is 'INPUT'
        if mterm.getIoType() == 'INPUT':
            # Append the MTerm to the list of input MTerms
            input_mterms.append(mterm)

    # Return a tuple containing MTerms of the library cell of instance inst_name_1 and input MTerms of instance inst_name_2
    return (mterms1, input_mterms)

# Example call to the function
results = get_mterms_and_input_mterms('_411_', 'input1')",Get the MTerms of the library cell of the instance '_411_' and get the list of mterms of the instance 'input1' whose IoType is 'INPUT'. Return the results as a tuple
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the LEF version of the technology
lef_version = tech.getLefVersion()

# get clearance measure of the technology
clearance_measure = tech.getClearanceMeasure()

# Set Db units per micron to 1500 for the chip
tech.setDbUnitsPerMicron(1500)

# Return the clearance measure and the LEF version of the technology
result = (clearance_measure, lef_version)",Get the clearance measure and set the Db units per micron to 1500 to the chip and get Lef version. return the result as a tuple.
"def check_input_pins_without_nets():
    # Get the design block
    block = ord.get_db_block()
    
    # Get all instances
    insts = block.getInsts()
    
    # Initialize a list to store input pins without nets
    input_pin_wout_net = []
    
    # Iterate over instances
    for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        
        # Iterate over pins
        for pin in pins:
            # Check if the pin is an input signal
            if pin.isInputSignal():
                # Get the net connected to the pin
                nets = pin.getNet()
                # Check if the pin has no net connected
                if nets is None:
                    # Append the pin to the list
                    input_pin_wout_net.append(pin)
    
    # Check if there are no input pins without nets
    return len(input_pin_wout_net) == 0

# Call the function and print the result
result = check_input_pins_without_nets()",Check if all the input pins of all instances have a valid net connection
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_split30_""
inst = block.findInst(""_split30_"")
# Set the instance as don't touch type
inst.setDoNotTouch(True)","Set the instance ""_split30_"" as don't touch type"
"# Get the design block
block = ord.get_db_block()
# Get all instances
insts = block.getInsts()
# Create a list to store pin names
pin_name_list = []
# Loop through all instances
for inst in insts:
    # Get the pins of this instance
    inst_ITerms = inst.getITerms()
    # Loop through all pins
    for ITerm in inst_ITerms:
        # Append pin names to the list
        pin_name_list.append(design.getITermName(ITerm))",Get the name of every pin
"# Invert the rotation and the location of instances with the library cell type 'NAND2_X1'.

# Get the design block
block = design.getBlock()

# Get all instances in the block
insts = block.getInsts()

# Iterate through all instances in the block
for inst in insts:
    # Check if the name of the library cell type is 'NAND2_X1'
    if inst.getMaster().getName() == 'NAND2_X1':
        # Invert the rotation and the location of the instance
        transform = inst.getTransform()
        transform.invert()
        inst.setTransform(transform)",Invert the rotation and the location of instances with the library cell type 'NAND2_X1'
"# Horizontally flip the rotation of the instances whose library cell types are 'AND2_X1'

#define flipping function
def flipX(value):
    if value == ""R0"":
      return ""MX""
    elif value == ""R90"":
      return ""MYR90""
    elif value == ""R180"":
      return ""MY""
    elif value == ""R270"":
      return ""MXR90""
    elif value == ""MY"":
      return ""R180""
    elif value == ""MYR90"":
      return ""R90""
    elif value == ""MX"":
      return ""R0""
    elif value == ""MXR90"":
      return ""R270""

# Get the design block
block = design.getBlock()

# Get all instances in the block
insts = block.getInsts()

# Iterate through all instances in the block
for inst in insts:
    # Check if the library cell type is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Horizontally flip the rotation of the instance
        orient = inst.getOrient()
        orient = flipX(orient)
        inst.setOrient(orient)",Horizontally flip the rotation of the instances whose library cell types are 'AND2_X1'
"# Horizontally flip the rotation of the instances whose library cell types are 'AND2_X1'

#define flipping function
def flipX(value):
    if value == ""R0"":
      return ""MX""
    elif value == ""R90"":
      return ""MYR90""
    elif value == ""R180"":
      return ""MY""
    elif value == ""R270"":
      return ""MXR90""
    elif value == ""MY"":
      return ""R180""
    elif value == ""MYR90"":
      return ""R90""
    elif value == ""MX"":
      return ""R0""
    elif value == ""MXR90"":
      return ""R270""

# Get the design block
block = design.getBlock()

# Get all instances in the block
insts = block.getInsts()

# Iterate through all instances in the block
for inst in insts:
    # Check if the library cell type is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Horizontally flip the rotation of the instance
        transform = inst.getTransform()
        orient = transform.getOrient()
        orient = flipX(orient)
        transform.setOrient(orient)
        inst.setTransform(transform)",Horizontally flip the rotation of the instances whose library cell types are 'AND2_X1'
"# Vertically flip the rotation of the instances whose library cell types are 'AND2_X1'

#define flipping function
def flipY(value):
    if value == ""R0"":
      return ""MY""
    elif value == ""R90"":
      return ""MXR90""
    elif value == ""R180"":
      return ""MX""
    elif value == ""R270"":
      return ""MYR90""
    elif value == ""MY"":
      return ""R0""
    elif value == ""MYR90"":
      return ""R270""
    elif value == ""MX"":
      return ""R180""
    elif value == ""MXR90"":
      return ""R90""

# Get the design block
block = design.getBlock()

# Get all instances in the block
insts = block.getInsts()

# Iterate through all instances in the block
for inst in insts:
    # Check if the library cell type is 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Vertically flip the rotation of the instance
        transform = inst.getTransform()
        orient = transform.getOrient()
        orient = flipY(orient)
        transform.setOrient(orient)
        inst.setTransform(transform)
",Vertically flip the rotation of the instances whose library cell types are 'AND2_X1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name 'metal8'
layer = tech.findLayer('metal8')
# Get the cut layer spacing rules
techLayerCutSpacingRules = layer.getTechLayerCutSpacingRules()",Get the cut layer spacing rules of layer with name 'metal8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal10"" 
layer = tech.findLayer('metal10')
# Return the end of line extension rules
techLayerEolExtensionRules = layer.getTechLayerEolExtensionRules()",Get the end of line extension rules of the technology layer with name 'metal10'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology object with technology information
tech = block.getTech()
# Find the layer with name ""via8"" 
layer = tech.findLayer('via8')
# Return the tech layer forbidden spacing rules
techLayerForbiddenSpacingRules = layer.getTechLayerForbiddenSpacingRules()",Get the forbidden spacing rules of the technology layer with name 'via8'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""via1"" 
layer = tech.findLayer('via1')
# Return the keepout zone rules
techLayerKeepOutZoneRules = layer.getTechLayerKeepOutZoneRules()",Get the keepout zone rules of the technology layer with name 'via1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer called ""OVERLAP"" 
layer = tech.findLayer('OVERLAP')
# Return two widths spacing rules
# API for version 5.7 two widths spacing rules, expressed as a 2D matrix
# with index tables
twoWidthsSpacingTableNumWidths = layer.getTwoWidthsSpacingTableNumWidths()",Get the two widths spacing rules of the technology layer with name 'OVERLAP'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name ""metal1"" 
layer = tech.findLayer('metal1')
# Return the min cut rules
techLayerMinCutRules = layer.getTechLayerMinCutRules()",Get the minimum cut rules of the technology layer with name 'metal1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the technology layer with name ""via2"" 
layer = tech.findLayer('via2')
# Return the  minimum step rules
techLayerMinStepRules = layer.getTechLayerMinStepRules()",Get the minimum step rules of the technology layer with name 'via2'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the collection of spacing rules for the object, assuming
# coding in LEF 5.4 format.
v54SpacingRules = layer.getV54SpacingRules()",Get the collection of spacing rules for the layer with name 'metal3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal4""
layer = tech.findLayer('metal4')
# Return the spacing end of line rules
techLayerSpacingEolRules = layer.getTechLayerSpacingEolRules()",Get the spacing end of line rules of layer with name 'metal4'
"def get_layer_type(layer_name):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Find the layer with the specified name
    layer = tech.findLayer(layer_name)
    
    # Return the layer type
    return layer.getType()

# Call the function with the argument ""metal5""
metal5_layer_type = get_layer_type('metal5')",Get the type of technology layer with name 'metal5'
"def get_via3_wrong_dir_spacing_rules():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Find the layer with name ""via3""
    layer = tech.findLayer('via3')
    
    # Return the wrong direction spacing rules
    return layer.getTechLayerWrongDirSpacingRules()

# Call the function to get the wrong direction spacing rules for ""via3""
via3_wrong_dir_spacing_rules = get_via3_wrong_dir_spacing_rules()",Get the wrong direction spacing rules of layer with name 'via3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal1""
layer = tech.findLayer('metal1')
# Return the x-axis offset
offset = layer.getOffset()",Get the offset along the x-axis of the technology layer with name 'metal1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal2""
layer = tech.findLayer('metal2')
# Return the x-axis offset
offsetX = layer.getOffsetX()",Get the offset along the x-axis of the technology layer with name 'metal2'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the y-axis offset
offsetY = layer.getOffsetY()",Get the offset along the y-axis of the technology layer with name 'metal3'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal3""
layer = tech.findLayer('metal3')
# Return the y-axis offset
layer.setOffsetXY(0.2, 0.15)",Change the offset setting along the x-axis to 0.2 microns and the y-axis to 0.15 microns for the technology layer named 'metal3'.
"def get_design_info():
    # Retrieve block information
    block = design.getBlock()
    
    # Get all instances
    insts = block.getInsts()
    
    # Get the technology information
    tech = block.getTech()
    
    # Initialize a dictionary to store instance halos
    inst_halos = {}
    
    # Iterate through each instance and store halo information
    for inst in insts:
        inst_halos[inst.getName()] = inst.getHalo()
    
    # Find layer information for 'metal4' and get EOL rules
    layer4 = tech.findLayer('metal4')
    layer_spacing_eol_rules = layer4.getTechLayerSpacingEolRules()
    
    # Find layer information for 'metal8' and get corner spacing rules
    layer8 = tech.findLayer('metal8')
    layer8_corner_spacing_rules = layer8.getTechLayerCornerSpacingRules()
    
    # Find layer information for 'metal5' and get cut class rules
    layer5 = tech.findLayer('metal5')
    layer_cut_class_rules = layer5.getTechLayerCutClassRules()
    
    # Store all the collected information in a dictionary
    result = {
        ""halos"": inst_halos,
        ""metal4_EOL"": layer_spacing_eol_rules,
        ""metal8_corner_spacing_rules"": layer8_corner_spacing_rules,
        ""cut_class_rules"": layer_cut_class_rules
    }
    
    # Return the collected information
    return result

# Call the function to get the design information
design_info = get_design_info()","Get the following in a dictionary, with the given key names:
1. get all the halos of the instances with inst name as key. the key should be halos.
2. Get the routing layers spacing EOL rules of layer with name 'metal4'. The key should be metal4_EOL.
3. Get the routing layers corner spacing rules of layer with name 'metal8'. The key should be metal8_corner_spacing_rules.
4. get the routing layers cut class rules of layer with name 'metal8'. The key name for this will be cut_class_rules."
"# Get the current design block
block = design.getBlock()

# Retrieve the capacitor-coupled segments
cc_segments = block.getCCSegs()

# Get all instances
insts = block.getInsts()

# Dictionary to store source type of instances on level 1 whose master cells are either NAND or NOR
src_type = {}

# Iterate through each instance
for inst in insts:
    # Get the library cell of the instance
    master = inst.getMaster()
    
    # Check if the library cell is special power type
    if master.isSpecialPower():
        # Set the master of the instance as frozen so dbMTerms cannot be added or delete from the master once it is frozen.
        inst.getMaster().setFrozen(True)
    
    # Check if the name of library cell is ""NAND2_X1"" or ""NOR3_X1"" and the instance is on level 1
    if (master.getName() == ""NAND2_X1"" or master.getName() == ""NOR3_X1"") and inst.getLevel() == 1:
        # Store the source type of the instance in the dictionary
        src_type[inst.getName()] = inst.getSourceType()","Retrieve the capacitor-coupled segments and frozen the library cells with special power type, then get source type of all the instances on level 1 whose master cells are either ""NAND2_X1"" or ""NOR3_X1""."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Find the instance '_411_'
inst1 = block.findInst('_411_')

# Set user-defined flags 1 and 3 for instance '_411_'
inst1.setUserFlag1()
inst1.setUserFlag3()

# Find the instance 'input1'
inst2 = block.findInst('input1')

# Mark the first output nets of the instances '_411_' and 'input1'
net1 = inst1.getFirstOutput().getNet()

# Dictionary to store instance transform offsets
inst_transform_offset_dict = {}

# Iterate through each instance
for inst in insts:
    # Check if the master cell name is ""AND2X_1""
    if inst.getMaster().getName() == ""AND2X_1"":
        # Store the offset of the instance with master 'AND2_X1'
        inst_transform_offset_dict[inst.getName()] = inst.getTransform().getOffset()","Set user-defined flags 1 and 3 for instance '_411_' and mark the first output nets of the instances '_411_' and 'input1', followed by getting the offset of the instances whose master is 'AND2_X1' in the form of dictionary with instance name as key."
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store instances and their respective regions
inst_regions = {}

# List to store pad instances on level 0
inst_list = []

# Iterate through each instance
for inst in insts:
    # Store instance name and its region in the inst_regions dictionary
    inst_regions[inst.getName()] = inst.getRegion()
    
    # Check if the instance is a pad and it's on level 0
    if inst.isPad() and inst.getLevel() == 0:
        # Append the instance to the list of pad instances
        inst_list.append(inst)
    
    # Check if the instance name is ""input1""
    if inst.getName() == ""input1"":
        # Iterate through each pin of the instance
        for pin in inst.getITerms():
            # Get the net connected to the pin
            net = pin.getNet()
            # Check if the net exists
            if net:
                # Set RC disconnected for the net
                net.setRCDisconnected(True)",Retrieve the instances and their corresponding areas if they are PAD or any of its subtypes and set as level 0. Proceed to disconnect the RC for the networks associated with the 'input1' instance.
"# Get the current design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Dictionary to store offsets of instances whose master cell is 'NAND2_X1'
NAND_offsets = {}

# Iterate through each instance
for inst in insts:
    # Check if the library cell name is ""NAND2_X1""
    if inst.getMaster().getName() == ""NAND2_X1"":
        # Store the xy location of the instance
        NAND_offsets[inst.getName()] = inst.getTransform().getOffset()
    
    # Check if the instance name is ""_411_""
    if inst.getName() == ""_411_"":
        # Iterate through each pin of the instance
        for pin in inst.getITerms():
            # Get the net connected to the pin
            net = pin.getNet()
            # Check if the net exists
            if net:
                # Set RC disconnected for the net
                net.setRCDisconnected(True)
",Get the offset of all 'NAND2_X1' cells and set the RC disconnected for the nets of the instance 'input1'.
"# Get the current block of the design
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get the count of Manufacturing Grid
mfg = tech.getManufacturingGrid()

# Find the net with name ""req_msg[13]""
net = block.findNet(""req_msg[13]"")

# Set the Capacitance Coupling Adjust Order of the net to 1
net.setCcAdjustOrder(1)","Get the count of manufacturing grid and set the capacitance Coupling Adjust Order of the net with name ""req_msg[13]"" to 1."
"# Get the nets of the input pins of instance 'output53'

block = design.getBlock()

# find the instance 'output53'
inst = block.findInst('output53')

# Initialize a list to store nets of input pins
input_nets = []

# Get all input pins (ITerms) of the instance
pins = inst.getITerms()

# Iterate through all input pins
for pin in pins:
    # Check if the pin is an input signal
    if pin.isInputSignal() and pin:
        # If it's an input signal, add its net to the list
        input_nets.append(pin.getNet())",get the nets connected to the input pins of the instance 'output53'
"# Retrieve all instances that have a hierarchy and whose library cell type is 'AND2_X1' and are on level 1.

block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store matching instances
inst_list = []

# Iterate through all instances
for inst in insts:
    # Check if the instance has hierarchy, its library cell is 'AND2_X1', and it is on level 1
    if inst.isHierarchical() and inst.getMaster().getName()==""AND2_X1"" and inst.getLevel() == 1:
        # Add the instance to the list
        inst_list.append(inst)",Retrieve all instances that have a hierarchy and whose library cell type is 'AND2_X1' and are on level 1.
"# Get the resistor segments

# Get the design block
block = design.getBlock()

# Return the resistor segments
RSegs = block.getRSegs()",get the resistor segments of the design block
"# Retrieve the LEQ (Logical equivalent) information associated with the library cell of instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Get the library cell associated with the instance
master = inst.getMaster()

# Retrieve the LEQ information
leq_info = master.getLEQ()",Retrieves the LEQ (Logical equivalent) information associated with the library cell of instance '_411_'
"# Get all the pad and set as level 1

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Initialize a list to store matching instances
inst_list = []

# Iterate through all instances
for inst in insts:
    # Check if the instance is a pad and it is level 1
    if inst.isPad() and inst.getLevel() == 1:
        # Add the instance to the list
        inst_list.append(inst)",get all the pad instances that are level 1 
"# Get the vertical thickness multiplier for the IO pin placer's parameters and set corner avoidance to 50

# Get the IO pin placer
iop = design.getIOPlacer()

# Get the parameters of the IO pin placer
parameters = iop.getParameters()

# Set corner avoidance to 50
parameters.setCornerAvoidance(50)

# Return the vertical thickness multiplier
verticalThicknessMultiplier = parameters.getVerticalThicknessMultiplier()",get the vertical thickness multiplier for the IO pin placer's parameters and set corner avoidance to 50
"# Get the design block
block = design.getBlock()

# Find the instance named ""FILLER_0_17_159""
inst = block.findInst(""FILLER_0_17_159"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Reverse the resistor segment sequence of the net
        net.reverseRSegs()
",Reverse the resistor segment seqence of the nets of the instance FILLER_0_17_159
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets with wire-ordered flag set as True
ordered_wires = []

# Iterate through each net
for net in nets:
    # Check if the wire-ordered flag is set to true
    if net.isWireOrdered():
        # Append the net to the list
        ordered_wires.append(net)","Get the nets if their wire-ordered flag is set as True, and return it as a list"
"# Get the design block
block = design.getBlock()

# List to store nets with ordered wires
ordered_wires = []

# List of net names
nets = [
    ""net1"",
    ""net10"",
    ""net11"",
    ""net12"",
    ""net13"",
    ""net14"",
    ""net15"",
    ""net16"",
    ""net17"",
    ""net18"",
    ""net19""
]

# Iterate through each net name
for name in nets:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the wire ordered flag to true
    net.setWireOrdered(True)
    
    # Append the net to the list of nets with ordered wires
    ordered_wires.append(net)","Set the wires ordered flag to true for the following nets and return a list of these nets: net1, net10, net11, net12, net13, net14, net15, net16, net17, net18, net19
"
"# Get the design block
block = design.getBlock()

# List to store nets 
altered_wires_net = []

# List of net names
nets = [
    ""_000_"",
    ""_001_"",
    ""_002_"",
    ""_003_"",
    ""_004_"",
    ""_005_"",
    ""_006_"",
    ""_007_"",
    ""_008_"",
    ""_009_"",
    ""_010_""
]

# Iterate through each net name
for name in nets:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the wire update flag to true
    net.setWireAltered(True)
    
    # Append the net to the list of nets
    altered_wires_net.append(net)","Set the wire update flag to true for the wires of the following nets and return a list of these nets: _000_, _001_, _002_, _003_, _004_, _005_, _006_, _007_, _008_, _009_, _010_
"
"# Get the design block
block = design.getBlock()

# List to store selected nets
selected_nets = []

# List of net names to select
net_names = [
    ""net1"",
    ""net10"",
    ""net11"",
    ""net12"",
    ""net13"",
    ""net14"",
    ""net15"",
    ""net16"",
    ""net17"",
    ""net18"",
    ""net19""
]

# Iterate through each net name
for name in net_names:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the net as selected
    net.setSelect(True)
    
    # Append the selected net to the list
    selected_nets.append(net)","set the select flag true for the following nets and return the list of these nets: net1, net10, net11, net12, net13, net14, net15, net16, net17, net18, net19
"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets
wild_connected_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is connected using a wild-card
    if net.isWildConnected():
        # Append the net to the list
        wild_connected_nets.append(net)",Get the nets connected using a wild-card.
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets marked as ""do not touch""
do_not_touch_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is set as ""do not touch""
    if net.isDoNotTouch():
        # Append the net to the list
        do_not_touch_nets.append(net)",Get the nets that are set as do not touch and return as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective coupled capacitor adjust orders
net_Cc_adjust_order = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its coupled capacitor adjust order in the dictionary
        net_Cc_adjust_order[net.getName()] = net.getCcAdjustOrder()",Get the coupled capacitor adjust order for the nets of the instance input6 and return the result as a dict with key being net name and value being the coupled capacitor adjust order
"# Get the design block 
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective wire types
net_wire_type = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its wire type in the dictionary
        net_wire_type[net.getName()] = net.getWireType()",Get the wire types of the nets connecting to the instance input6 and return the result as a dictionary with key being net name and value being the wire type
"# Get the design block
block = design.getBlock()

# List to store marked nets
marked_nets = []

# List of net names to mark
nets_to_mark = [
    ""resp_msg[4]"",
    ""resp_msg[5]"",
    ""resp_msg[6]"",
    ""resp_msg[7]"",
    ""resp_msg[8]"",
    ""resp_msg[9]"",
    ""resp_rdy"",
    ""resp_val""
]

# Iterate through each net name
for name in nets_to_mark:
    # Find the net object by name
    net = block.findNet(name)
    
    # Set the mark flag of the net to True
    net.setMark(True)
    
    # Append the marked net to the list
    marked_nets.append(net)","Set mark flags to the nets resp_msg[4], resp_msg[5], resp_msg[6], resp_msg[7], resp_msg[8], resp_msg[9], resp_rdy, resp_val and return the list of market nets."
"# Get thedesign block
block = design.getBlock()

# Find the instance named ""input6""
inst = block.findInst(""input6"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective total resistances
net_total_resistance = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its total resistance in mil ohms in the dictionary
        net_total_resistance[net.getName()] = net.getTotalResistance()","Get the total resistance in mil ohms of the nets connecting to the instance ""input6"" and return the result as a dict using net name as key and resistance as value"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets connected by abutment
abutment_nets = []

# Iterate through each net
for net in nets:
    # Check if the net have its pins connected by abutment
    if net.isConnectedByAbutment():
        # Append the net to the list
        abutment_nets.append(net)",Get the nets that have their pins connected by abutment and return as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""_699_""
inst = block.findInst(""_699_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective coupled capacitor match ratio
net_cc_match_ratio = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its coupled capacitor match ratio in the dictionary
        net_cc_match_ratio[net.getName()] = net.getCcMatchRatio()","Get the coupled capacitor match ratio of the nets connecting to the instance ""_699_"" and return as a dict using net name as key and coupled capacitor match ratio as value"
"# Get the design block
block = design.getBlock()

# Find the instance named ""input10""
inst = block.findInst(""input10"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective node capacitors
net_cap_nodes = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its cap nodes in the dictionary
        net_cap_nodes[net.getName()] = net.getCapNodes()","Get the node capacitor of the RC segment belong to each net connecting to the instance input10, and return the result as a dict with net name being keys and node capacitors as values"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name ""metal4""
layer = tech.findLayer('metal4')
# Return the pitch of the layer
pitch = layer.getPitch()","Get the pitch setting of ""metal 4"" layer"
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store extracted nets
extracted_nets = []

# Iterate through each net
for net in nets:
    # Check if the net is extracted
    if net.isExtracted():
        # Append the extracted net to the list
        extracted_nets.append(net)",Get all extracted nets as a list
"# Get the design block
block = design.getBlock()

# Find the instance named ""input10""
inst = block.findInst(""input10"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective routing guides
net_guides = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its routing guides in the dictionary
        net_guides[net.getName()] = net.getGuides()","Get the routing guides of the nets connecting to the instance ""input10"" as a dictionary, using net name as keys and routing guide as values"
"# Get the design block
block = design.getBlock()

# Find the instance named ""FILLER_0_17_13""
inst = block.findInst(""FILLER_0_17_13"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective tracks
net_tracks = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its tracks in the dictionary
        net_tracks[net.getName()] = net.getTracks()","Get the tracks of the nets connecting to the instance ""FILLER_0_17_13"", and return it as a dict using net name as keys and tracks as values"
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer29""
inst = block.findInst(""rebuffer29"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Reverse the coupled capacitor segments of the net
        net.reverseCCSegs()",Reverse the coupled capacitor segments of the nets connecting to the instance called rebuffer29
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer9""
inst = block.findInst(""rebuffer9"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective driving ITerms
net_driving_iterm = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its driving term id assigned of this net. -1 if not set, 0 if non existent
        net_driving_iterm[net.getName()] = net.getDrivingITerm()","Get the driving term ids for the nets connecting to the instance rebuffer9, and return the rsult as a dict using net name as keys and driving term ids as values"
"# Get the design block
block = design.getBlock()

# Find the instance named ""_706_""
inst = block.findInst(""_706_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective Cap node counts
net_cap_node_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its node capacitor count in the dictionary
        net_cap_node_count[net.getName()] = net.getCapNodeCount()","Get the node capacitor count of RC segments of the nets connecting to the instance _706_, and return the result as a dictionary with keys being net name, and values being node capacitor count  "
"# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()

# List to store nets that are RC graphs
rc_graph_nets = []

# Iterate through each net
for net in nets:
    # Check if the rc_graph flag set, and the flag is set when Rseg and CapNodes were created
    if net.isRCgraph():
        # Append the net to the list 
        rc_graph_nets.append(net)","Get all the nets if their rc_graph flag is set, and return the result as a list"
"# Get the design block
block = design.getBlock()

# Find the instance named ""split30""
inst = block.findInst(""split30"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective term counts
net_term_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and the amount of pins and ports of this net in the dictionary
        net_term_count[net.getName()] = net.getTermCount()","Get the amount of pins and ports of the nets connecting to the instance ""split30"" and return it as a dictionary with net name being keys"
"# Get the design block
block = design.getBlock()

# Find the instance named ""clkbuf_0_clknet_2_3__leaf_clk""
inst = block.findInst(""clkbuf_0_clknet_2_3__leaf_clk"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective x-talk classes
net_X_Talk_class = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its x-talk class in the dictionary
        net_X_Talk_class[net.getName()] = net.getXTalkClass()","Get the x-talk-class of the nets connecting to the instance ""clkbuf_0_clknet_2_3__leaf_clk"", as a dictionary with the net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""rebuffer5""
inst = block.findInst(""rebuffer5"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective first BTerms
net_first_bterms = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its first BTerm in the dictionary
        net_first_bterms[net.getName()] = net.get1stBTerm()","Get the first port of the nets connecting to the instance rebuffer5, as a dictionary with the net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""input22""
inst = block.findInst(""input22"")

# Get all pins (interface terms) connecting to the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective R segment counts
net_R_seg_count = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its R segment count in the dictionary
        net_R_seg_count[net.getName()] = net.getRSegCount()","Get the R segment count of the RC network connected to the nets of the instance input22, return the result as a dictionary with net names as key values."
"# Get the design block
block = design.getBlock()

# Find the instance named ""_686_""
inst = block.findInst(""_686_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective nondefault rule applied for wiring
net_non_default_rule = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and the nondefault rule applied to this net for wiring in the dictionary, returns nullptr if there is no nondefault rule.
        net_non_default_rule[net.getName()] = net.getNonDefaultRule()",Get the nondefault rule applied to the nets connected to the instance _686_ as a dictionary with the net names as key values.
"# Get the design block
block = design.getBlock()

# Find the instance named ""_706_""
inst = block.findInst(""_706_"")

# Get all pins (interface terms) of the instance
pins = inst.getITerms()

# Dictionary to store net names and their respective zeroth R segments
net_zero_R_segment = {}

# Iterate through each pin of the instance
for pin in pins:
    # Get the net connected to the pin
    net = pin.getNet()
    
    # Check if a net is connected to the pin
    if net:
        # Store the net name and its zeroth R segment in the dictionary
        net_zero_R_segment[net.getName()] = net.getZeroRSeg()",Get the zeroth R segment of the nets of the instance _706_ as a dictionary with the net names as key values.
"# Get the current design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Get all layers defined in the technology
layers = tech.getLayers()

# Dictionary to store layer directions with their names
layer_direction_dict = {}

# Dictionary to store upper and lower layers of the 'poly' layer
poly_upper_lower_layers = {}

# Iterate through each layer
for layer in layers:
    # Store the direction of the layer with its name in the dictionary
    layer_direction_dict[layer.getName()] = layer.getDirection()
    
    # If the layer name is 'poly', store its upper and lower layers
    if layer.getName() == ""poly"":
        poly_upper_lower_layers = {
            ""upper"": layer.getUpperLayer(),
            ""lower"": layer.getLowerLayer()
        }

# Create a result dictionary containing layer directions and 'poly' upper and lower layers
result = {
    ""layer_directions"": layer_direction_dict,
    ""poly"": poly_upper_lower_layers
}","Get the routing directions of the layers with their names as keys and also get the layers above and below the layer with name 'poly'. Finally, return them as dict of dicts"
"def get_io_placer_report():
    # Get the IO Placer object of the design
    iop = design.getIOPlacer()

    # Get the parameters of the IO Placer
    parameters = iop.getParameters()

    # Construct the output string with corner avoidance, HPWL report, and number of slots
    output_string = ""Corner Avoidance: {}\nHPWL Report: {}\nNumber of slots: {}"".format(
        parameters.getCornerAvoidance(),
        parameters.getReportHPWL(),
        parameters.getNumSlots()
    )

    return output_string

# Call the function to get the IO Placer report
io_placer_report = get_io_placer_report()","Get the corner avoidance, number of slots and HPWL report of the IO pin placer"
"def get_io_placer_lengths():
    # Get the IO Placer object of the design
    iop = design.getIOPlacer()

    # Get the parameters of the IO Placer
    parameters = iop.getParameters()

    # Return the vertical and horizontal length as a tuple
    return (parameters.getVerticalLength(), parameters.getHorizontalLength())

# Call the function to get the lengths
io_placer_lengths = get_io_placer_lengths()",Get the vertical and horizontal length of the setting of the IO pin placer
"from openroad import Tech, Design

tech = Tech()
# Make sure you have files read into OpenROAD DB
design = Design(tech)

floorplan = design.getFloorplan() 
# Set the floorplan utilization to 50% 
floorplan_utilization = 50 
# Set the aspect ratio of the design (height/width) as 0.66 
floorplan_aspect_ratio = 0.66 
# Set the spacing between core and die as 10 um
floorplan_core_spacing = [design.micronToDBU(10) for i in range(4)] 
# Find the site in lef
site = floorplan.findSite(""site_name"")
floorplan.initFloorplan(floorplan_utilization, floorplan_aspect_ratio,  
                        floorplan_core_spacing[0], floorplan_core_spacing[1], 
                        floorplan_core_spacing[2], floorplan_core_spacing[3], site) 
floorplan.makeTracks()","Show me the piece of code to perform floorplanning using a utilization rate of 50% and an aspect ratio of 0.66, and set the spacing between the core and the die to 10 microns"
"def get_master_types_of_instances():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()

    # Retrieve all instances present in the design block
    insts = block.getInsts()

    # Initialize an empty list to store the names of library cell type for each instance
    masters_list = []

    # Iterate over each instance in the design block
    for inst in insts:
        # Retrieve the library cell type of the current instance
        master_type = inst.getMaster()
        # Get the name of the library cell type
        master_type_name = master_type.getName()
        # Append the name of the library cell type to the list
        masters_list.append(master_type_name)

    return masters_list

# Call the function to get the master types
master_types_list = get_master_types_of_instances()",Give me the names of library cell type of every instance
"def get_instance_levels():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    
    # Dictionary to store the level of each instance
    level_of_instance = {}
    
    # Iterate over each instance in the design block
    for inst in insts:
        # Retrieve the name of the instance and its level, then store it in the dictionary
        level_of_instance[inst.getName()] = inst.getLevel()

    return level_of_instance

# Call the function to get the instance levels
instance_levels = get_instance_levels()",Get the level of all instances with the instance name as a dictionary. Key of the dictionary is name of the instance and value is the level of the instance
"def get_const_names_of_instances():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    
    # Initialize an empty list to store the constant names of the instances
    const_name = []
    
    # Iterate over each instance in the design block
    for inst in insts:
        # Append the constant name of the instance
        const_name.append(inst.getConstName())

    return const_name

# Call the function to get the constant names
constant_names = get_const_names_of_instances()",Get all the Constant names of the instances and return as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
print("" name       | net_type | pin&wire_capacitance"")
# Retrieve all nets present in the design block
nets = block.getNets()
# Iterate over each net in the design block
for net in nets:
        # Get the net capacitance
        pin_and_wire_cap = timing.getNetCap(net, corner, timing.Max)
        # Get the name of the net
        net_name = net.getName()
        # Get the signal Type of the net
        net_type = net.getSigType()
        print(f""{net_name:<12}| {net_type:<9}| {pin_and_wire_cap:19.4e}"")","Write a code to Print the name of the net, its net type, and the wire capacitance of all the nets"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Retrieve all instances present in the design block
insts = block.getInsts()
print("" name        | rise_arrival_time | fall_arrival_time | rise_slack | fall_slack | slew"")
# Iterate over each instance in the design block
for inst in insts:
        # Get the pins associated with the instance
        inst_ITerms = inst.getITerms()
        # Iterate through all the pins
        for pin in inst_ITerms:
                # Check if the pin is in supply
                if design.isInSupply(pin):
                        continue
                # Get the pin name
                pin_name = design.getITermName(pin)
                # Get the pin rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Get the pin fall arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Get the pin rise slack
                pin_rise_slack = timing.getPinSlack(pin, timing.Fall, timing.Max)
                # Get the pin fall slack
                pin_fall_slack = timing.getPinSlack(pin, timing.Rise, timing.Max)
                # Get the pin slew
                pin_slew = timing.getPinSlew(pin)
                print(f""{pin_name:<12} | {pin_rise_arr:17.4e} | {pin_fall_arr:17.4e} | {pin_rise_slack:10.4e} | {pin_fall_slack:10.4e} | {pin_slew:6.4e}"") ","Write a code to print all the pin names, rising arrival time, fall arrival time, rise stack, fall stack and slew of all the pins"
"def get_number_of_library_cell_types():
    # Get the OpenROAD database
    db = ord.get_db()
    
    # Get the number of library cell types
    return db.getNumberOfMasters()

# Call the function to get the number of library cell types
num_library_cell_types = get_number_of_library_cell_types()",Get the number of library cells in the library
"def calculate_die_area():
    # Get the design block
    block = ord.get_db_block()

    # Get the die area of the design
    area = block.getDieArea()

    # Get the width and height of the die area
    dx = area.dx()
    dy = area.dy()

    # Calculate the die area
    die_area = dx * dy

    return die_area

# Call the function to calculate the die area
die_area = calculate_die_area()",Get the die area
"def calculate_core_area():
    # Get the design block
    block = ord.get_db_block()

    # Get the core area of the design
    area = block.getCoreArea()

    # Get the width and height of the core area
    dx = area.dx()
    dy = area.dy()

    # Calculate the core area
    core_area = dx * dy

    return core_area

# Call the function to calculate the core area
core_area = calculate_core_area()",Get the core area
"def report_global_connections():
    # Get the design block
    block = ord.get_db_block()

    # Report global connection of the design
    global_connection = block.reportGlobalConnect()

    return global_connection

# Call the function to report global connections
global_connections = report_global_connections()",Report all the global connection rules
"def calculate_total_pins():
    # Get the design block
    block = ord.get_db_block()

    # Initialize a variable to store the total number of pins
    total_pins = 0

    # Get instances
    insts = block.getInsts()

    # Iterate over instances
    for inst in insts:
        # Add the number of pins of the instance to the total
        total_pins += len(inst.getITerms())

    return total_pins

# Call the function to calculate the total number of pins
total_pins = calculate_total_pins()",Get the total number of pins
"def check_clock_nets_exist():
    # Get the design block
    block = ord.get_db_block()

    # Initialize a list to store clock nets
    clock_nets = []

    # Get all nets
    nets = block.getNets()

    # Iterate over nets
    for net in nets:
        # Check if the net is a CLOCK net
        if net.getSigType() == 'CLOCK':
            clock_nets.append(net)

    # Check if CLOCK nets exist
    return len(clock_nets) > 0

# Call the function to check for the existence of clock nets
clock_nets_exist = check_clock_nets_exist()",Check if the design has any clock nets
"def count_power_and_ground_nets():
    # Get the design block
    block = ord.get_db_block()

    # Initialize variables to count power and ground nets
    power_nets = 0
    ground_nets = 0

    # Get all nets
    nets = block.getNets()

    # Iterate over nets
    for net in nets:
        # Check if the net is a POWER net
        if net.getSigType() == 'POWER':
            power_nets += 1
        # Check if the net is a GROUND net
        elif net.getSigType() == 'GROUND':
            ground_nets += 1

    # Return the counts of power and ground nets
    return power_nets, ground_nets

# Call the function to get the counts of power and ground nets
power_net_count, ground_net_count = count_power_and_ground_nets()",Get the total number of power and ground nets
"# Get the chip associated with the design's block.

# Retrieve the design block
block = design.getBlock()  

# Get the chip associated with the design block.
chip = block.getChip()  ",Give me the chip of a given block
"# Get the nets in a given block

# Get the design block
block = design.getBlock()

# Get all nets
nets = block.getNets()",Get all nets in a given block
design.getBlock().getName(),Get the name of the design block
"# Get the logic ports for a given block

# Get the design block
block = design.getBlock()

# Get all logic ports
logic_ports = block.getLogicPorts()",Get the logic ports for a given block
"# Get the location of all instances
# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through all instances
for inst in insts:
    # Print the instance name and its location
    print(inst.getName(), ""Location:"", inst.getLocation())",Get the location of all instances
"def is_instance_placed(instance_name):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Iterate through all instances
    for inst in insts:
        # Check if the instance name matches the target instance
        if inst.getName() == instance_name:
            # Return the placement status of the instance
            return inst.isPlaced()

    # Return None if the instance is not found
    return None

# Call the function to check if 'FILLER_0_0_1' is placed
is_filler_placed = is_instance_placed('FILLER_0_0_1')",Check if the instance 'FILLER_0_0_1' placed or not
"def get_instance_children(instance_name):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Iterate through all instances
    for inst in insts:
        # Check if the instance name matches the target instance
        if inst.getName() == instance_name:
            # Get the children instances of the target instance
            return inst.getChildren()

    # Return an empty list if the instance is not found or has no children
    return []

# Call the function to get the children of 'FILLER_0_0_1'
filler_children = get_instance_children('FILLER_0_0_1')",Get the children of 'FILLER_0_0_1' instance
"def get_net_with_max_capacitance(block, timing, corner):
    # Get all nets
    nets = block.getNets()
    # Initialize variables to track the net with the maximum capacitance
    max_cap_net = None
    max_cap = float('-inf')
    # Iterate over nets
    for net in nets:
        # Get the total capacitance of the net
        cap = timing.getNetCap(net, corner, timing.Max)
        # Check if the capacitance of the current net is greater than the maximum capacitance found so far
        if cap > max_cap:
            # Update the maximum capacitance and the corresponding net
            max_cap = cap
            max_cap_net = net
    # Return the name of the net with the maximum capacitance
    return max_cap_net.getName() if max_cap_net else None

# Example usage:
# Assuming `ord`, `timing`, and `corner` are initialized appropriately.
block = ord.get_db_block()
net_with_max_cap = get_net_with_max_capacitance(block, timing, corner)",Identify the nets with the highest capacitance
"def get_high_fanout_nets():
    # Get the design block
    block = ord.get_db_block()        
    # Get all nets
    nets = block.getNets()
    # Define the fanout threshold
    gt_fanout = 10
    # Initialize a list to store nets with fanout greater than the threshold
    net_fanout = []
    # Iterate over nets
    for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
            # Check if the ITerm represents an input signal
            if net_ITerm.isInputSignal():
                # Get the name of the pin
                pin_name = design.getITermName(net_ITerm)
                # Append the pin name to the list of output pins
                output_pins.append(pin_name)
        # Check if the number of output pins exceeds the fanout threshold
        if len(output_pins) > gt_fanout:
            # Append the net name and its fanout to the list
            net_fanout.append([net_name, len(output_pins)])
    # Return the list of nets with fanout greater than the threshold
    return net_fanout

# Call the function
high_fanout_nets = get_high_fanout_nets()",Give me a list of nets with a fanout greater than 10
"# Get the design block
block = ord.get_db_block()
# Get all nets
nets = block.getNets()
# Initialize variables to store maximum fanout and its corresponding net
max_fanout = 0
# Lists to store net names and their corresponding fanouts
net_fanout_list = []
net_name_list = []
# Iterate over nets
for net in nets:
        # Get the name of the net
        net_name = net.getName()
        # Initialize a list to store output pins
        output_pins = []
        # Get all ITerms associated with the net
        net_ITerms = net.getITerms()
        # Iterate over ITerms
        for net_ITerm in net_ITerms:
                # Check if the ITerm represents an input signal
                if (net_ITerm.isInputSignal()):
                        # Get the name of the pin
                        pin_name = design.getITermName(net_ITerm)
                        # Append the pin name to the list of output pins
                        output_pins.append(pin_name)
         # Append the net name and its fanout to the respective lists
         net_name_list.append(net_name)        
         net_fanout_list.append(len(output_pins))
# Find the maximum fanout
max_fanout = max(net_fanout_list)
# Find the index of the net with the maximum fanout
max_fanout_index = net_fanout_list.index(max_fanout)
# Get the name of the net with the maximum fanout
max_fanout_net = net_name_list[max_fanout_index]
# Return the net with the maximum fanout
return max_fanout_net",Give me a list of nets with the maximum fanout 
"def get_unique_master_cell_names():
    # Get the design block
    block = ord.get_db_block()
    # Get all instances
    insts = block.getInsts()
    # Initialize a list to store unique name of library cell types
    masters_list = []
    # Iterate over instances
    for inst in insts:
        # Get the master associated with the instance
        mast = inst.getMaster()
        mast_name = mast.getName()        
        # Check if the library cell name is not already in the list
        if mast_name not in masters_list:
            # Append the library cell name to the list
            masters_list.append(mast_name)
    # Return the list of unique library cell names
    return masters_list

# Call the function
unique_masters = get_unique_master_cell_names()",List all the library cells used
"# Get the design block
block = ord.get_db_block()
# Get the total number of connections (nets)
total_connections = len(block.getNets())",Get the total number of connections (nets)
"def get_io_nets():
    # Get the design block
    block = design.getBlock()

    # Get all nets
    nets = block.getNets()

    # Initialize a list to store input/output nets
    io_nets = []

    # Iterate through all nets
    for net in nets:
        # Check if the net is an input/output net
        if net.isIO():
            # If it's an input/output net, add it to the list
            io_nets.append(net)

    # Return the list of input/output nets
    return io_nets

# Call the function
io_nets = get_io_nets()",get all the input output nets for a given block
"def get_output_pins():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a list to store output pins
    output_pins_list = []

    # Iterate through all instances
    for inst in insts:
        # Get all input pins (ITerms) of the instance
        pins = inst.getITerms()
        # Iterate through all input pins
        for pin in pins:
            # Check if the pin is an output signal
            if pin.isOutputSignal():
                # If it's an output signal, add it to the list
                output_pins_list.append(pin)

    # Return the list of output pins
    return output_pins_list

# Call the function
output_pins = get_output_pins()",get a list of all the output pins
"def get_nets_for_instance(inst_name):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a variable to store the nets of the instance
    nets = None

    # Iterate through all instances
    for inst in insts:
        # Check if the instance name matches the target instance
        if inst.getName() == inst_name:
            # Get all pins (ITerms) of the instance and extract their associated nets
            nets = [pin.getNet() for pin in inst.getITerms()]
            break

    # Return the nets of the instance
    return nets

# Call the function with the instance name '_411_'
instance_nets = get_nets_for_instance('_411_')",Give me all nets connecting to the instance '_411_'
"def get_instance_weights():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store weights of instances
    inst_weight_dict = {}

    # Iterate through all instances
    for inst in insts:
        # Get the instance name
        name = inst.getName()
        # Check if the instance name is not already in the dictionary
        if name not in inst_weight_dict:
            # If not, add the instance name and its weight to the dictionary
            inst_weight_dict[name] = inst.getWeight()

    # Return the dictionary containing weights of instances
    return inst_weight_dict

# Call the function to get the instance weights
instance_weights = get_instance_weights()",get Weights of all the instances
"def get_instance_bbox_dimensions(inst_name='_411_'):
    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(inst_name)

    # Get the length and width of the Bounding Box of the instance
    length = inst.getBBox().getLength()
    width = inst.getBBox().getWidth()

    # Return the length and width
    return (length, width)

# Call the function to get the length and width of the instance '_411_'
bbox_dimensions = get_instance_bbox_dimensions('_411_')",get length and width of the bounding Box of the instance ''_411_'
"def get_source_types_of_instances_at_level(level=1):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store source types of instances at the specified level
    inst_src_type_dict = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the instance is at the specified level
        if inst.getLevel() == level:
            # Add the instance name and its source type to the dictionary
            inst_src_type_dict[inst.getName()] = inst.getSourceType()

    # Return the dictionary containing source types of instances at the specified level
    return inst_src_type_dict

# Call the function to get source types of instances on level 1
lvl1_inst_src_type = get_source_types_of_instances_at_level(1)",get source type of all the instance on level 1
"# Set the placement status of the instance '_411_' to 'UNPLACED'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Set the placement status of the instance to 'UNPLACED'
inst.setPlacementStatus('UNPLACED')
",set the placement Status of the instance '_411_' to 'UNPLACED'
"# Get all the blockages

# Get the design block
block = design.getBlock()

# Return all blockages
blockages = block.getBlockages()",get all the blockages
"# Reset the tapcell in the design

# Get the tapcell in the design
tapcell = design.getTapcell()

# Reset the tapcell
tapcell.reset()",reset the tapcell in the design
"# Retrieve the capacitor-coupled segments

# Get the design block
block = design.getBlock()

# Return the capacitor-coupled segments
CCSegs = block.getCCSegs()",retrieve the capacitor-coupled segments
"def get_sites_of_rows():
    # Get the design block
    block = design.getBlock()

    # Get all rows
    rows = block.getRows()

    # Initialize a dictionary to store row names and their corresponding sites
    row_site_dict = {}

    # Iterate through all rows
    for row in rows:
        # Add the row name and its site to the dictionary
        row_site_dict[row.getName()] = row.getSite()

    # Return the dictionary containing row names and their sites
    return row_site_dict

# Call the function to get the sites of rows
row_sites = get_sites_of_rows()",get the sites of rows
"def get_row_site_dimensions():
    # Get the design block
    block = design.getBlock()

    # Get all rows
    rows = block.getRows()

    # Initialize a dictionary to store row names and their corresponding site dimensions
    row_site_dict = {}

    # Iterate through all rows
    for row in rows:
        # Check if the row has a site
        if row.getSite():
            # Add the row name and its site dimensions to the dictionary
            row_site_dict[row.getName()] = [row.getSite().getHeight(), row.getSite().getWidth()]

    # Return the dictionary containing row names and their site dimensions
    return row_site_dict

# Call the function to get row site dimensions
row_site_dimensions = get_row_site_dimensions()",get the height and width of the sites of each row
"# Get the location, orientation, direction, and spacing of rows

# Get the design block
block = design.getBlock()

# Get all rows
rows = block.getRows()

# Iterate through all rows
for i in range(len(rows)):
    row = rows[i]
    # Print row information
    print(""Row"", i, row.getName())
    print(""Location:"", row.getOrigin())
    print(""Rotation:"", row.getOrient())
    print(""Direction:"", row.getDirection())
    print(""Block spacing:"", row.getSpacing())
","get the location, rotation, direction and spacing of rows"
"def get_rows_with_hybrid_sites():
    # Get the design block
    block = design.getBlock()

    # Get all rows
    rows = block.getRows()

    # Initialize a list to store rows with hybrid sites
    hybrid_row_site = []

    # Iterate through all rows
    for i in range(len(rows)):
        row = rows[i]
        site = row.getSite()
        # Check if the site is hybrid
        if site.isHybrid():
            # Append the row and its site to the list
            hybrid_row_site.append((row, site))

    # Return the list of rows with hybrid sites
    return hybrid_row_site

# Call the function to get rows with hybrid sites
hybrid_rows = get_rows_with_hybrid_sites()",get the rows with hybrid sites
"def get_instances_and_halos():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store instances and their halos
    inst_halos = {}

    # Iterate through all instances
    for inst in insts:
        # Add the instance name and its halo to the dictionary
        inst_halos[inst.getName()] = inst.getHalo()

    # Return the dictionary containing instances and their halos
    return inst_halos

# Call the function to get instances and their halos
instances_and_halos = get_instances_and_halos()",get all the instances and there halos
"def get_instances_and_regions():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store instances and their regions
    inst_regions = {}

    # Iterate through all instances
    for inst in insts:
        # Add the instance name and its region to the dictionary
        inst_regions[inst.getName()] = inst.getRegion()

    # Return the dictionary containing instances and their regions
    return inst_regions

# Call the function to get instances and their regions
instances_and_regions = get_instances_and_regions()",get the instances and their respective regions
"def get_and_set_do_not_touch():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store do not touch instances
    do_not_touch_elements = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the instance is marked as do not touch
        if inst.isDoNotTouch():
            # Add the instance to the dictionary
            do_not_touch_elements[inst.getName()] = inst
        else:
            # Set do not touch to true for instances marked as false
            inst.setDoNotTouch(True)

    # Return the dictionary containing do not touch instances
    return do_not_touch_elements

# Call the function to get and set ""do not touch"" instances
do_not_touch_instances = get_and_set_do_not_touch()",get the all the do not touch instance and set do not touch to true if false for instances 
"def set_eco_create_and_destroy(inst_name):
    # Get the design block
    block = design.getBlock()

    # Find the instance by name
    inst = block.findInst(inst_name)

    # Set EcoCreate and EcoDestroy to true
    inst.setEcoCreate(True)
    inst.setEcoDestroy(True)

    # Return the modified instance
    return inst

# Call the function for instance '_411_'
modified_instance = set_eco_create_and_destroy('_411_')",set the EcoCreate and EcoDestroy for instance '_411_' true
"# Mark the first output nets of the instances '_411_' and 'input1'

# Get the design block
block = design.getBlock()

# Find the instances '_411_' and 'input1'
inst1 = block.findInst('_411_')
inst2 = block.findInst('input1')

# Mark the first output net of instance '_411_'
inst1.getFirstOutput().getNet().setMark(True)

# Mark the first output net of instance 'input1'
inst2.getFirstOutput().getNet().setMark(True)
",mark the first output nets of the instances '_411_' and 'input1'
"def get_rc_disconnected_nets():
    # Get the design block
    block = design.getBlock()

    # Get all the nets
    nets = block.getNets()

    # Initialize a list to store RC disconnected nets
    rc_disconnected_nets = []

    # Iterate through all the nets
    for net in nets:
        # Check if the net is RC disconnected
        if net.isRCDisconnected():
            # Add the net to the list
            rc_disconnected_nets.append(net)

    # Return the list of RC disconnected nets
    return rc_disconnected_nets

# Call the function to get RC disconnected nets
disconnected_nets = get_rc_disconnected_nets()",Get the nets that are disconnected from RC network
"def get_placement_boundary_points():
    # Hard-coded parameters
    block_name = '_411_'

    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(block_name)

    # Get the library cell associated with the instance
    master = inst.getMaster()

    # Get the placement bounding box of the library cell
    placement_boundary = master.getPlacementBoundary()

    # Return the points of the placement bounding box
    return placement_boundary.getPoints()

# Call the function and store the result
boundary_points = get_placement_boundary_points()
print(boundary_points)",get the points of the placement bounding box of the library cell of the instance '_411_'
"# Clear user flags of instance '_411_'

# Get the design block
block = design.getBlock()

# Find the instance with name '_411_'
inst = block.findInst('_411_')

# Clear user flags 1, 2, and 3 of the instance
inst.clearUserFlag1()
inst.clearUserFlag2()
inst.clearUserFlag3()",clear user flags of instance '_411_'
"def check_end_cap_status():
    # Hard-coded parameter
    instance_name = '_411_'

    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Check if the instance is marked as an end cap
    return inst.isEndCap()

# Call the function and store the result
is_end_cap = check_end_cap_status()
print(is_end_cap)",Check if the instance '_411_' is marked as an end cap cell.
"def map_nets_to_wires():
    # Get the design block
    block = design.getBlock()

    # Get all nets
    nets = block.getNets()

    # Initialize a dictionary to store net-wire mappings
    net_wire_dict = {}

    # Iterate through all nets
    for net in nets:
        # Get the name of the net
        net_name = net.getName()
        
        # If the net name is not already in the dictionary, initialize an empty list
        if net_name not in net_wire_dict:
            net_wire_dict[net_name] = []
        
        # Append the wire connected to the net to the list in the dictionary
        net_wire_dict[net_name].append(net.getWire())

    # Return the net-wire dictionary
    return net_wire_dict

# Call the function and store the result
net_wire_mapping = map_nets_to_wires()
print(net_wire_mapping)",map nets to the wires
"def get_master_cell_mterms():
    # Hard-coded parameter
    instance_name = '_411_'

    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Get the MTerms of the master cell
    mterms = inst.getMaster().getMTerms()

    # Return the MTerms
    return mterms

# Call the function and store the result
master_cell_mterms = get_master_cell_mterms()
print(master_cell_mterms)",get the MTerms of the master cell of the instance '_411_'
"def get_iotypes_of_pins():
    # Hard-coded parameter
    instance_name = '_411_'

    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Get the MTerms of the master cell
    mterms = inst.getMaster().getMTerms()

    # Initialize a dictionary to store IoTypes
    iotype_dict = {}

    # Iterate through all MTerms
    for term in mterms:
        # Store the IoType of each term in the dictionary
        iotype_dict[term.getName()] = term.getIoType()

    # Return the dictionary containing IoTypes
    return iotype_dict

# Call the function and store the result
pin_iotypes = get_iotypes_of_pins()
print(pin_iotypes)",get the IoType of the pins of the instance '_411_'
"def get_non_core_instances():
    # Get the design block
    block = design.getBlock()

    # Get all instances in the block
    insts = block.getInsts()

    # Initialize an empty list for non-core instances
    inst_list = []

    # Iterate through all instances
    for inst in insts:
        # If the instance's master cell is not a core, add it to the list
        if not inst.getMaster().isCore():
            inst_list.append(inst)

    # Return the list of non-core instances
    return inst_list

# Call the function and store the result
non_core_instances = get_non_core_instances()
print(non_core_instances)",get the instances whose masters are not of type CORE
"def get_num_masks_per_layer():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the number of masks for each layer
    num_masks = {}

    # Iterate through all layers
    for layer in layers:
        # Store the number of masks for each layer
        num_masks[layer.getName()] = layer.getNumMasks()

    # Return the dictionary containing the number of masks for each layer
    return num_masks

# Call the function and store the result
layer_masks = get_num_masks_per_layer()
print(layer_masks)",get the number of masks of each layer
"def get_clearance_measure():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Return the clearance measure
    return tech.getClearanceMeasure()

# Call the function and store the result
clearance_measure = get_clearance_measure()
print(clearance_measure)",get the measure system
"def check_use_min_spacing():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Return whether UseMinSpacingObs is set in the technology
    return tech.getUseMinSpacingObs()

# Call the function and store the result
use_min_spacing = check_use_min_spacing()
print(use_min_spacing)",Check LEF USEMINSPACING is set or not
"def get_rect_only_layers():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a list to store layers set as RectOnly
    rect_layers = []

    # Iterate through all layers
    for layer in layers:
        # Check if the layer is set as RectOnly
        if layer.isRectOnly():
            # Append the rectangle-only layer to the list
            rect_layers.append(layer)

    # Return the list of rectangle-only layers
    return rect_layers

# Call the function and store the result
rect_only_layers = get_rect_only_layers()
print(rect_only_layers)",Get the layers if they are set as isRectOnly
"def get_layer_aliases():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the Alias of each layer
    layer_alias = {}

    # Iterate through all layers
    for layer in layers:
        # Store the Alias of each layer
        layer_alias[layer.getName()] = layer.getAlias()

    # Return the dictionary containing the Alias of all layers
    return layer_alias

# Call the function and store the result
layer_aliases = get_layer_aliases()
print(layer_aliases)",Get the alias of all the layers
"def set_layer_aliases():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the Alias of each layer
    layer_alias = {}

    # Iterate through all layers
    for layer in layers:
        # Construct the Alias using the layer index
        alias = ""Layer "" + str(layer.getNumber())
        
        # Set the Alias of the layer
        layer.setAlias(alias)
        
        # Store the Alias of the layer in the dictionary
        layer_alias[layer.getName()] = alias

    # Return the dictionary containing the updated Alias of layers
    return layer_alias

# Call the function and store the result
updated_layer_aliases = set_layer_aliases()
print(updated_layer_aliases)","Set the Alias of the layers by the name convention ''layer i"" where i is the index of the layer"
"# Get LEF version

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return the LEF version of the technology
LefVersion = tech.getLefVersion()",Get LEF version
"# Get LEF version as a string

# Get the design block
block = design.getBlock()

# Get the technology information
tech = block.getTech()

# Return the LEF version of the technology as a string
LefVersionString = tech.getLefVersionStr()",Get LEF version as a string
"def get_layer_resistances():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the resistance of each layer
    layer_resistance = {}

    # Iterate through all layers
    for layer in layers:
        # Get the resistance of the layer and store it in the dictionary
        layer_resistance[layer.getName()] = layer.getResistance()

    # Return the dictionary containing the resistance of each layer
    return layer_resistance

# Call the function and store the result
layer_resistances = get_layer_resistances()
print(layer_resistances)",Get the resistance of all the layers
"def get_layer_edge_capacitances():
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Get all layers
    layers = tech.getLayers()

    # Initialize a dictionary to store the edge capacitance of each layer
    layer_edge_capacitance = {}

    # Iterate through all layers
    for layer in layers:
        # Get the edge capacitance of the layer and store it in the dictionary
        layer_edge_capacitance[layer.getName()] = layer.getEdgeCapacitance()

    # Return the dictionary containing the edge capacitance of each layer
    return layer_edge_capacitance

# Call the function and store the result
layer_edge_capacitances = get_layer_edge_capacitances()",get edge capacitance of all the layers
"def get_upper_lower_layers(layer_name):
    # Get the design block
    block = design.getBlock()

    # Get the technology information
    tech = block.getTech()

    # Find the layer with the specified name
    layer = tech.findLayer(layer_name)

    # Return the upper and lower layer of the specified layer
    return (layer.getUpperLayer(), layer.getLowerLayer())

# Call the function and store the result with 'metal5' as the argument
upper_lower_layers = get_upper_lower_layers('metal5')",get the upper and lower layer of the layer 'metal5'
"def check_buffer_and_end_cap():
    # Hard-coded parameter
    instance_name = '_411_'

    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Get the master of the instance
    master = inst.getMaster()

    # Check if the design is buffer for the master and if the master is End Cap
    return design.isBuffer(master) and master.isEndCap()

# Call the function and store the result
buffer_and_end_cap_status = check_buffer_and_end_cap()",Check if instance '_411_' is buffer and if it is an End Cap cell
"def process_sequential_instances():
     target_inst_name = ""_411_""
    
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock(block_name)  # Get the block
    insts = block.getInsts()  # Get all instances

    seq_insts = []  # List to store sequential instances
    
    # Iterate through instances
    for inst in insts:
        master = inst.getMaster()  # Get the master of the instance
        
        # Check if the instance is '_411_'
        if inst.getName() == target_inst_name:
            # Make the master of instance '_411_' sequential
            master.setSequential(True)
        
        # Check if the master is of type sequential
        if master.isSequential():
            seq_insts.append(inst)
    
    # Return sequential instances
    return seq_insts

# Call the function
sequential_instances = process_sequential_instances()",Get the instances whose masters are of type sequential and make the master of instance '_411_' sequential
"def check_clocked_pins(inst_name):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Find the instance based on the provided name
    inst = block.findInst(inst_name)
    
    # Get all pins of the instance
    pins = inst.getITerms()

    clocked_ports = []  # List to store pins set as clocked
    
    # Check if any pin is set as clocked
    for pin in pins:
        if pin.isClocked():
            clocked_ports.append(pin)
    
    # Return clocked ports
    return clocked_ports

# Call the function with '_411_' as an argument
clocked_pins = check_clocked_pins('_411_')",Check if the instance '411' has any pin set as clocked
"# Display the location, orient, direction, and spacing of each row
block = design.getBlock()
rows = block.getRows()

# Print table header
print(""{:<15} {:<15} {:<15} {:<15}"".format(""Row Name"", ""Location"", ""Direction"", ""Spacing""))

# Print data in a table format
for row in rows:
    location = str(row.getOrigin())
    direction = str(row.getDirection())
    spacing = str(row.getSpacing())
    
    print(""{:<15} {:<15} {:<15} {:<15}"".format(row.getName(), location, direction, spacing))","Display the location, orient, direction, and spacing of each row"
"def get_rows_and_output_pins_by_orient(orient):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    rows = block.getRows()  # Get all rows
    insts = block.getInsts()  # Get all instances

    output_pins_dict = {}  # Dictionary to store output pins
    orient_rows = []  # List to store rows with the specified orientation

    # Iterate over rows to find those with the specified rotation orientation
    for row in rows:
        if row.getOrient() == orient:
            orient_rows.append(row)

    # Iterate over instances to find their output pins
    for inst in insts:
        if inst.getFirstOutput():
            output_pins_dict[inst.getName()] = inst.getFirstOutput()

    # Return the rows with the specified orientation and output pins of instances
    return (orient_rows, output_pins_dict)

# Call the function with 'MX' as the argument
orient_rows, output_pins_dict = get_rows_and_output_pins_by_orient('MX')",Get the rows with 'MX' rotation and get the instances and the first output pin of all instances.
"def get_instances_halos_and_regions():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    insts = block.getInsts()  # Get all instances

    inst_halo_region_dict = {}  # Dictionary to store instance names with their halos and regions

    # Iterate over instances to collect their halos and regions
    for inst in insts:
        inst_halo_region_dict[inst.getName()] = (inst.getHalo(), inst.getRegion())

    # Return the dictionary with instance names as keys and a tuple of halo net and region as values
    return inst_halo_region_dict

# Call the function
inst_halo_region_dict = get_instances_halos_and_regions()",Get all the instances and their halos and regions in a dictionary with the instance name as the key and a tuple of halo net and region as value
"def set_do_not_touch_and_eco_create_destroy(inst_name):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    insts = block.getInsts()  # Get all instances
    
    dnt_insts = []  # List to store 'Do Not Touch' instances

    # Iterate over instances to set 'Do Not Touch' for pads and collect 'Do Not Touch' instances
    for inst in insts:
        if inst.isPad():
            inst.setDoNotTouch(True)  # Set Do Not Touch to True for pad instances
        
        if inst.isDoNotTouch():
            dnt_insts.append(inst)  # Collect Do Not Touch instances
        
        # Set the EcoCreate and EcoDestroy for the specified instance to True
        if inst.getName() == inst_name:
            inst.setEcoCreate(True)
            inst.setEcoDestroy(True)

    # Return the list of 'Do Not Touch' instances
    return dnt_insts

# Call the function with '_411_' as an argument
dnt_insts = set_do_not_touch_and_eco_create_destroy('_411_')",Get the all the do not touch instances and set do not touch to true for pad instances and set the EcoCreate and EcoDestroy for instance '_411_' to True.
"def mark_first_output_and_set_rc_disconnected(inst_name1, inst_name2):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block

    # Find the instances by names
    inst1 = block.findInst(inst_name1)
    inst2 = block.findInst(inst_name2)

    # Mark the first output nets of the instances and set RC disconnected true for the nets
    inst1.getFirstOutput().getNet().setMark(True)
    inst2.getFirstOutput().getNet().setMark(True)

    # Set RC disconnected true for the net of the first output of the first instance
    inst1.getFirstOutput().getNet().setRCDisconnected(True)

    # Set RC disconnected true for the net of the first output of the second instance
    inst2.getFirstOutput().getNet().setRCDisconnected(True)

# Call the function with '_411_' and 'input1' as arguments
mark_first_output_and_set_rc_disconnected('_411_', 'input1')",Mark the first output nets of the instances '411' and 'input1' and set RC disconnected to True for the nets.
"def set_rc_disconnected_and_get_coordinates(inst_name):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Find the instance by name
    inst = block.findInst(inst_name)
    
    # Set RC disconnected true for the nets of the instance
    nets = [pin.getNet() for pin in inst.getITerms()]
    for net in nets:
        if net:
            net.setRCDisconnected(True)
    
    # If the instance is '_411_', get the placement coordinates of its master cell
    if inst.getName() == ""_411_"":
        placement_boundary = inst.getMaster().getPlacementBoundary()
        coordinates = {
            ""ul"": placement_boundary.ul(),
            ""ll"": placement_boundary.ll(),
            ""lr"": placement_boundary.lr(),
            ""ur"": placement_boundary.ur()
        }
        return coordinates

# Call the function with 'input1' to set RC disconnected and get coordinates for '_411_'
coordinates = set_rc_disconnected_and_get_coordinates('input1')","Set the RC disconnected true for the nets of the instance 'input1' and get the upper-left, lower-left, lower-right, upper-right coordinates of the placement bounding box of the master cell of the instance '411'."
"def clear_user_flags_and_get_placement_points(inst_name):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Find the instance by name
    inst = block.findInst(inst_name)
    
    # Get the placement bounding box of the master cell of the instance
    placement_boundary = inst.getMaster().getPlacementBoundary()
    
    # Get the points of the placement bounding box
    points = placement_boundary.getPoints()

    # Clear user flags 1, 2, and 3 of the instance
    inst.clearUserFlag1()
    inst.clearUserFlag2()
    inst.clearUserFlag3()

    # Return the points of the placement bounding box
    return points

# Call the function with '_411_' to clear user flags and get placement points
placement_points = clear_user_flags_and_get_placement_points('_411_')",Get the points of the placement bounding box of the master cell of the instance '411' and clear user flags of instance '_411_'.
"def getMasterCellCoordinates():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get all instances
    instances = block.getInsts()
    
    # Initialize a dictionary to store coordinates for each master cell
    masterCoordinates = {}

    # Iterate through each instance
    for instance in instances:
        # Get the master cell of the instance
        masterCell = instance.getMaster()
        
        # Get the placement bounding box of the master cell
        placementBoundary = masterCell.getPlacementBoundary()
        
        # Check if the master cell name is not already in the masterCoordinates dictionary
        if masterCell.getName() not in masterCoordinates:
            # Store the center x, y coordinates, and minimum and maximum x, y coordinates in the dictionary
            masterCoordinates[masterCell.getName()] = {
                ""center"": [placementBoundary.xCenter(), placementBoundary.yCenter()],
                ""min"": [placementBoundary.xMin(), placementBoundary.yMin()],
                ""max"": [placementBoundary.xMax(), placementBoundary.yMax()]
            }

    # Return the dictionary containing coordinates for each master cell
    return masterCoordinates

# Call the function to get the coordinates
masterCoordinates = getMasterCellCoordinates()","Get the center x, y and minimum and maximum x, y coordinates of the placement bounding box of the master cell of the all instance."
"def getLayerSpacingAndMasks():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # Dictionary to store spacing and number of masks for each layer
    spacingAndMask = {}

    # Iterate through each layer in the technology
    for layer in layers:
        # Store the spacing and number of masks for the current layer in the dictionary
        spacingAndMask[layer.getName()] = {
            ""spacing"": layer.getSpacing(),
            ""masks"": layer.getNumMasks()
        }

    # Return the dictionary containing spacing and number of masks for each layer
    return spacingAndMask

# Call the function to get the spacing and masks for all layers
layerSpacingAndMasks = getLayerSpacingAndMasks()",Get the spacing and the number of masks of each layer
"def getBlockagesAndRCDisconnectedNets(instanceName):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get all blockages
    blockages = block.getBlockages()
    
    # Get all nets
    nets = block.getNets()
    
    # List to store RC disconnected nets
    rcDisconnectedNets = []

    # Iterate through each net
    for net in nets:
        # Check if the net is RC disconnected
        if net.isRCDisconnected():
            # Append the net to the list of RC disconnected nets
            rcDisconnectedNets.append(net)

    # Find the instance by name passed as argument
    inst = block.findInst(instanceName)

    # Get the MTerms of the master cell of the specified instance
    mterms = inst.getMaster().getMTerms()

    # Return a tuple containing blockages, RC disconnected nets, and MTerms
    return (blockages, rcDisconnectedNets, mterms)

# Call the function with 'rebuffer7' as the argument
blockagesRCDisconnectedNetsMterms = getBlockagesAndRCDisconnectedNets('rebuffer7')","Get all the blockages and get the nets that are RC disconnected, followed by getting the MTerms of the master cell of the instance 'rebuffer7'."
"def getHorizontalLayersAndTechInfo():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # Define the direction for the layers
    direction = 'HORIZONTAL'
    
    # List to store horizontal tech layers and their capacitance
    horizontalLayers = []

    # Iterate through each layer in the technology
    for layer in layers:
        # Check if the layer direction is HORIZONTAL
        if layer.getDirection() == direction:
            # Append the layer and its capacitance to the list of horizontal layers
            horizontalLayers.append((layer, layer.getCapacitance())) 

    # Retrieve the clearance measure
    clearanceMeasure = tech.getClearanceMeasure()

    # Get the setting of UseMinSpacingObs in the tech file
    minSpaceObs = tech.getUseMinSpacingObs()

    # Construct a dictionary containing horizontal layers, clearance measure, and minimum spacing obstacle
    result = {
        ""horizontalLayers"": horizontalLayers,
        ""clearanceMeasure"": clearanceMeasure,
        ""minSpaceObs"": minSpaceObs
    }

    # Return the result dictionary
    return result

# Call the function to get horizontal layers and tech info
horizontalLayersTechInfo = getHorizontalLayersAndTechInfo()","Get the horizontal layers and their capacitance, then retrieve the clearance measure system and check if UseMinSpacingObs is set for this technology"
"def getRowAndNetInfo():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get rows and nets
    rows = block.getRows()
    nets = block.getNets()

    # Dictionary to store row information with row index as key
    rowInfoDict = {}

    # Dictionary to store sites of rows with row name as key
    rowSiteDict = {}

    # Dictionary to map nets to wires
    netWireDict = {}

    # Iterate through each row
    for i in range(len(rows)):
        row = rows[i]
        # Store row information in the rowInfoDict
        rowInfoDict[i] = {
            ""location"": row.getOrigin(),
            ""rotation"": row.getOrient(),
            ""direction"": row.getDirection(),
            ""spacing"": row.getSpacing()
        }
        
        # Store site of the row in the rowSiteDict
        rowSiteDict[row.getName()] = row.getSite()

    # Iterate through each net
    for net in nets:
        # Map net name to its wire
        netWireDict[net.getName()] = net.getWire()

    # Return a tuple containing row information, row sites, and net wire mappings
    return (rowInfoDict, rowSiteDict, netWireDict)

# Call the function to get row and net information
rowAndNetInfo = getRowAndNetInfo()","Get the location, rotation, direction, and spacing of rows as a dictionary with row index as key and get the sites of rows, followed by a dictionary with nets as keys and their wires as values."
"# Get the tapcell and reset it
tap_cell = design.getTapcell()
tap_cell.reset()

# Get the current block of the design
block = design.getBlock()

# Find the instance '_411_'
inst = block.findInst('_411_')

# Set the placement status of the instance to 'UNPLACED'
inst.setPlacementStatus('UNPLACED')

# Retrieve the capacitor-coupled segments
cc_segs = block.getCCSegs()

# Return the coupling capacitance segments
return cc_segs","reset the tapcell, set the placement Status of the instance '_411_' to 'UNPLACED' and retrieve the capacitor-coupled segments of the bock"
"# Get the tapcell in the design and reset it
tap_cell = design.getTapcell()
tap_cell.reset()

# Get the current block of the design
block = design.getBlock()

# Return all blockages
Blockages = block.getBlockages()",Get all the blockages and reset the tapcell in the design.
"def markOutputNetsAndGetCoordinates(instanceName1, instanceName2):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Find the instances by names passed as arguments
    inst1 = block.findInst(instanceName1)
    inst2 = block.findInst(instanceName2)

    # Mark the first output nets of the instances
    inst1.getFirstOutput().getNet().setMark(True)
    inst2.getFirstOutput().getNet().setMark(True)

    # Get the placement bounding box of the master cell of the instance '_411_'
    placementBoundary = inst1.getMaster().getPlacementBoundary()

    # Extract coordinates of the placement bounding box
    coordinates = {
        ""ul"": placementBoundary.ul(),
        ""ll"": placementBoundary.ll(),
        ""lr"": placementBoundary.lr(),
        ""ur"": placementBoundary.ur()
    }

    # Return the coordinates
    return coordinates

# Call the function with '_411_' and 'input1' as arguments
coordinates = markOutputNetsAndGetCoordinates('_411_', 'input1')","Mark the first output nets of the instances '_411_' and 'input1' and get the ul, ll, lr, ur coordinates of the placement bounding box of the master cell of the instance '_411_'."
"def getNonCoreMasterInstancesAndHorizontalLayers(direction):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get all instances
    insts = block.getInsts()
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # List to store horizontal tech layers and their capacitance
    horizontalLayers = []

    # List to store instances whose masters are not of type CORE
    nonCoreMasterInsts = []

    # Iterate through each instance
    for inst in insts:
        # Check if the master cell of the instance is not of type CORE
        if not inst.getMaster().isCore():
            # Append the instance to the list of non-core master instances
            nonCoreMasterInsts.append(inst)

    # Iterate through each layer in the technology
    for layer in layers:
        # Check if the layer direction matches the passed direction
        if layer.getDirection() == direction:
            # Append the layer and its capacitance to the list of horizontal layers
            horizontalLayers.append((layer, layer.getCapacitance()))

    # Reset the tapcell
    tapCell = design.getTapcell()
    tapCell.reset()

    # Return a tuple containing non-core master instances and horizontal layers
    return (nonCoreMasterInsts, horizontalLayers)

# Call the function with 'HORIZONTAL' as the argument
direction = 'HORIZONTAL'
nonCoreMasterInstsAndHorizontalLayers = getNonCoreMasterInstancesAndHorizontalLayers(direction)","Get the instances whose masters are not of type CORE and get the horizontal tech layers and their capacitance, followed by resetting the tapcell"
"def getRectOnlyLayerAliases():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # Initialize a list to store layers that are set as RectOnly
    rectLayersAlias = []

    # Iterate through all layers
    for layer in layers:
        # Check if the layer is set as RectOnly
        if layer.isRectOnly():
            # Append the rectangle-only layer aliases to the list
            rectLayersAlias.append(layer.getAlias())

    # Return the list of rectangle-only layers
    return rectLayersAlias

# Call the function to get the rectangle-only layer aliases
rectLayersAlias = getRectOnlyLayerAliases()",Get the layers that are set as RectOnly and get their alias.
"def getLayerResistanceAndEdgeCapacitance():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # Initialize dictionaries to store resistance and edge capacitance of all layers
    layerResistance = {}
    layerEdgeCapacitance = {}

    # Iterate through each layer to retrieve resistance and edge capacitance
    for layer in layers:
        layerResistance[layer.getName()] = layer.getResistance()
        layerEdgeCapacitance[layer.getName()] = layer.getEdgeCapacitance()

    # Combine resistance and edge capacitance dictionaries into a single result dictionary
    result = {
        ""edge_capacitance"": layerEdgeCapacitance,
        ""layer_resistance"": layerResistance
    }

    # Return the result dictionary
    return result

# Call the function to get the layer resistance and edge capacitance
layerDetails = getLayerResistanceAndEdgeCapacitance()",Get the resistance and edge capacitance of all the layers
"def handlePortAndGetLogicPorts(portName):
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Find the port with the given name
    port = block.findBTerm(portName)

    # Disconnect the port from the nets it is connected to
    port.disconnect()

    # Set the port to special
    port.setSpecial()

    # Get the logic ports
    logicPorts = block.getLogicPorts()

    # Return the logic ports
    return logicPorts

# Call the function with 'req_val' as the argument to handle the port
logicPorts = handlePortAndGetLogicPorts('req_val')","Disconnect the port named 'req_val' from the nets it is connected to and set the port named 'req_val' to special, and return the logic ports"
"def getUpdatedNetsAndHorizontalLayers():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get all nets
    nets = block.getNets()

    # Get the wire updated nets
    updatedNets = block.getWireUpdatedNets(nets)
    
    # Get the technology information
    tech = block.getTech()
    
    # Get all layers defined in the technology
    layers = tech.getLayers()
    
    # List to store horizontal layers in the technology file
    horizontalLayers = []
    
    # Iterate through each layer in the technology
    for layer in layers:
        # Check if the layer direction is 'HORIZONTAL'
        if layer.getDirection() == 'HORIZONTAL':
            # Append the horizontal layer to the list
            horizontalLayers.append(layer)

    # Create a dictionary containing updated nets and horizontal layers
    result = {
        ""nets"": updatedNets,
        ""layers"": horizontalLayers
    }

    # Return the result dictionary
    return result

# Call the function to get updated nets and horizontal layers
updatedNetsAndLayers = getUpdatedNetsAndHorizontalLayers()",Get all the wire_updated nets and get the horizontal layers
"def getLayerAndPortInfo():
    # Assuming `design.getBlock()` and similar functions are available in the environment
    block = design.getBlock()  # Get the block
    
    # Get the technology information
    tech = block.getTech()
    
    # Get the count of layers
    layerCount = tech.getLayerCount()
    
    # Get the Routing Layer Count
    routingLayerCount = tech.getRoutingLayerCount()
    
    # Get the logic ports
    logicPorts = block.getLogicPorts()
    
    # Create a dictionary containing layer count, routing layer count, and logic ports
    result = {
        ""layer_count"": layerCount,
        ""routing_layer_count"": routingLayerCount,
        ""logic_ports"": logicPorts
    }

    # Return the result dictionary
    return result

# Call the function to get layer count, routing layer count, and logic ports
layerAndPortInfo = getLayerAndPortInfo()","Get the count of layers and get the routing layer count, along with the logic ports"
"# Get the current block of the design
block = design.getBlock()

# Find the net with name ""req_msg[11]""
net1 = block.findNet(""req_msg[11]"")
# Set the Capacitance Coupling Adjust Factor to 1
net1.setCcAdjustFactor(1)

# Find the net with name ""req_msg[12]""
net2 = block.findNet(""req_msg[12]"")
# Set the Capacitance Coupling Calibration Factor to 2
net2.setCcCalibFactor(2)","Set the Capacitance Coupling Adjust Factor of the net with name ""req_msg[11]"" to 1 and set the Capacitance Coupling Calib Factor of the net with name ""req_msg[12]"" to 2."
"def getClockPins():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the pins (which are also called Iterms in OpenROAD)
    pins = block.getITerms()
    
    result = []
    
    # Iterate through all the pins
    for pin in pins:
        # Check if the pin is in clock
        if design.isInClock(pin.getInst()):
            # Append the pin to the result
            result.append(pin)
    
    # Return the list of clock pins
    return result

# Call the function to get the clock pins
clockPins = getClockPins()",Get all the Pins which are in clock net as a list.
"def getInstanceBBox(instance_name):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Find the instance with the given name
    inst = block.findInst(instance_name)
    
    # Get the Bounding box of the instance
    BBox = inst.getBBox()
    
    # Get the X Minimum of the Bounding Box of the instance
    xmin = BBox.xMin()
    
    # Get the Y Minimum of the Bounding Box of the instance
    ymin = BBox.yMin()
    
    # Get the X Maximum of the Bounding Box of the instance
    xmax = BBox.xMax()
    
    # Get the Y Maximum of the Bounding Box of the instance
    ymax = BBox.yMax()
    
    # Return the coordinates of the bounding box
    return [[xmin, ymin], [xmax, ymax]]

# Call the function with the instance name ""input1""
instanceBBox = getInstanceBBox(""input1"")","Get the Bounding Box of an instance named ""input1"". Return a list of coordinates (Xmin, Ymin in one list and Xmax, Ymax in next list) "
"def getLibrariesAndCells(db):
    # Get all the libraries in the database
    libs = db.getLibs()
    library_cells_dict = {}

    # Iterate through all the libraries
    for lib in libs:
        # Get the library cells of the library
        master_cells = lib.getMasters()
        cells = []

        # Iterate through all the library cells
        for master in master_cells:
            # Append the library cell to the cells list
            cells.append(master)

        # Add the library name and its cells to the dictionary
        library_cells_dict[lib.getName()] = cells

    return library_cells_dict

# Example of how to call the function
libraries_and_cells = getLibrariesAndCells(db)",Get all the library cells as a dictionary of list. Key of the dictionary is library name and the value is the list of all the library cells in the library file 
"def getLibraryCellNames(db):
    # Get all the libraries in the database
    libs = db.getLibs()
    libcell_name_list = []

    # Iterate through all libraries
    for lib in libs:
        # Get all library cells in this library file
        lib_masters = lib.getMasters()

        # Iterate through all library cells
        for master in lib_masters:
            # Get the name of the library cell
            libcell_name = master.getName()
            # Add the name to the list
            libcell_name_list.append(libcell_name)

    return libcell_name_list

# Example of how to call the function
library_cell_names = getLibraryCellNames(db)",Get the name of every liberty cell
"def get_instance_orientations():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    orientation = []
    
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    
    # Iterate over each instance in the design block
    for inst in insts:
        # Append the name and orientation of the instance
        orientation.append([inst.getName(), inst.getOrient()])
    
    return orientation

# Call the function and store the result
instance_orientations = get_instance_orientations()",Get the rotations of all instances as a list of lists
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst('input1')
# Set the rotation of the instance as ""MX""
inst.setOrient('MX')",Set the rotation of an instance 'input1' as 'MX'
"def get_output_nets(instance_name):
    # Get the current block from the design
    block = design.getBlock()

    # Retrieve the instance within the design
    inst = block.findInst(instance_name)

    # Initialize a list to store the net of the output pin
    output_nets = []

    pins = inst.getITerms()

    # Iterate through each pin of the instance
    for pin in pins:
        # Check if the pin represents an output signal
        if pin.isOutputSignal():
            # Retrieve the net associated with this output pin
            net = pin.getNet()
            # If net is not None then append it to the output_nets
            if net:
                output_nets.append(net)
    
    return output_nets

# Call the function with the desired instance name
output_nets_for_instance = get_output_nets('output53')",get the nets of the output pins of the instance 'output53'
"def get_instance_bbox_dimensions(instance_name):
    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Get the Bounding Box
    bounding_box = inst.getBBox()

    # Get the DX and DY of the Bounding Box of the instance
    return (bounding_box.getDX(), bounding_box.getDY())

# Call the function with the desired instance name
bbox_dimensions = get_instance_bbox_dimensions('_411_')",Get the width and height of the bounding box of instance '_411_'
"# Set the level of all 'AND2_X1' gate instances in the design to 1

# Get the design block
block = design.getBlock()

# Get all instances
insts = block.getInsts()

# Iterate through all instances
for inst in insts:
    # Check if the instance's master name contains 'AND2_X1'
    if inst.getMaster().getName() == 'AND2_X1':
        # Set the level of the instance to 1
        inst.setLevel(1, False)",set the level of all 'AND2_X1' gate instance in the design to 1
"def get_lower_left_corners(cell_type):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store the coordinates of the lower-left corner of the bounding box of the instances
    inst_to_master_transform_offset = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the name of the library cell type matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Add the instance name and the coordinates of the lower-left corner of the bounding box to the dictionary
            inst_to_master_transform_offset[inst.getName()] = inst.getTransform().getOffset()

    return inst_to_master_transform_offset

# Call the function with 'AND2_X1' as the argument
and2_x1_coordinates = get_lower_left_corners('AND2_X1')",Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'
"def get_lower_left_corners(cell_type):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store the coordinates of the lower-left corner of the bounding box of the instances
    inst_to_master_transform_offset = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the name of the library cell type matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Add the instance name and the coordinates of the lower-left corner of the bounding box to the dictionary
            inst_to_master_transform_offset[inst.getName()] = inst.getOrigin()

    return inst_to_master_transform_offset

# Call the function with 'AND2_X1' as the argument
and2_x1_coordinates = get_lower_left_corners('AND2_X1')",Get the coordinates of the lower-left corner of the bounding box of the instances whose library cell type is 'AND2_X1'
"def get_instance_orientations(cell_type):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store the orientation of instances
    inst_to_master_transform_orient = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the master name matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Add the instance name and its orientation to the dictionary
            inst_to_master_transform_orient[inst.getName()] = inst.getTransform().getOrient()

    return inst_to_master_transform_orient

# Call the function with 'AND2_X1' as the argument
and2_x1_orientations = get_instance_orientations('AND2_X1')",Retrieve the rotation of instances that have 'AND2_X1' as their library cell type.
"def get_instance_orientations(cell_type):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store the orientation of instances
    inst_to_master_transform_orient = {}

    # Iterate through all instances
    for inst in insts:
        # Check if the master name matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Add the instance name and its orientation to the dictionary
            inst_to_master_transform_orient[inst.getName()] = inst.getOrient()

    return inst_to_master_transform_orient

# Call the function with 'AND2_X1' as the argument
and2_x1_orientations = get_instance_orientations('AND2_X1')",Retrieve the rotation of instances that have 'AND2_X1' as their library cell type.
"def get_instance_first_output_pins():
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Initialize a dictionary to store instances and their output pins
    inst_outputs = {}

    # Iterate through all instances
    for inst in insts:
        # Add the instance name and its first output pin to the dictionary
        inst_outputs[inst.getName()] = inst.getFirstOutput()

    return inst_outputs

# Call the function to get the instance output pins
instance_output_pins = get_instance_first_output_pins()",Get the first output pin of an instance and map it to the instance names as the value in the dictionary.
"def set_user_flags_for_instance(instance_name):
    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Set the user-defined flags 1 and 3 to true
    inst.setUserFlag1()
    inst.setUserFlag3()

    # Return the modified instance
    return inst

# Call the function with the desired instance name
modified_instance = set_user_flags_for_instance('_411_')",Set the user-defined flags 1and 3 to true for instance '_411_' and return the instance
"def get_placement_bounding_box_coordinates(instance_name):
    # Get the design block
    block = design.getBlock()

    # Find the instance with the specified name
    inst = block.findInst(instance_name)

    # Get the master cell associated with the instance
    master = inst.getMaster()

    # Get the placement bounding box of the master cell
    placement_boundary = master.getPlacementBoundary()

    # Get the coordinates of the placement bounding box
    # Upper Left placement bounding box
    ul = placement_boundary.ul()
    # Lower Left placement bounding box
    ll = placement_boundary.ll()
    # Lower Right placement bounding box
    lr = placement_boundary.lr()
    # Upper Right placement bounding box
    ur = placement_boundary.ur()

    # Return the coordinates as a list
    coordinates = [ul, ur, lr, ll]
    return coordinates

# Call the function with the desired instance name
placement_coordinates = get_placement_bounding_box_coordinates('_411_')","get the upper left, upper right, lower left, lower right coordinates of the placement bounding box of the master cell of the instance '_411_'"
"def check_instance_and_collect_hierarchical_instances(instance_name, target_master_name):
    # Get the current block of the design
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Find the specified instance
    inst = block.findInst(instance_name)

    # Check if the instance is of type ENDCAP or any of its subtypes
    inst_is_endcap = inst.isEndCap()

    # Clear user-defined flags of the specified instance
    inst.clearUserFlag1()
    inst.clearUserFlag2()
    inst.clearUserFlag3()

    # List to store instances having hierarchy and whose library cell name matches the target
    inst_list = []

    # Iterate through each instance
    for inst in insts:
        # Check if the instance is hierarchical, its library cell name matches the target, and is level 1
        if inst.isHierarchical() and inst.getMaster().getName() == target_master_name and inst.getLevel() == 1:
            # Append the instance to the list
            inst_list.append(inst)

    # Return a tuple containing the status of the specified instance and the list of hierarchical instances
    return (inst_is_endcap, inst_list)

# Call the function with the desired instance name and target master name
result = check_instance_and_collect_hierarchical_instances('_411_', 'AND2X_1')","Check if the instance '_411_' is type ENDCAP or any of its subtypes, and clear user-defined flags of instance '_411_', then get all the instances with hierarchicy and whose library cell is AND2X_1 and the instance is level 1."
"def get_instance_design_block(instance_name):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Find the instance with the specified name
    inst = block.findInst(instance_name)
    
    # Return the corresponding design block of the instance
    return inst.getBlock()

# Call the function with the desired instance name
design_block = get_instance_design_block('input1')","Given the instance name 'input1', get the design block this instance belongs to."
"def get_db_units_per_micron():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Return the DB units per micron
    return block.getDbUnitsPerMicron()

# Call the function to get the DB units per micron
db_units_per_micron = get_db_units_per_micron()",Convert 1 um to units used in this technology in OpenROAD
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the DEF units of this technology
DefUnit =  block.getDefUnits()",Get the DEF units of this technology.
"def get_db_rows_info():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the DB rows
    rows = block.getRows()
    d = {}
    
    # Iterate through all the rows
    for row in rows:
        # Get the name of the DB row
        name = row.getName()
        # Get the spacing of the DB row
        spacing = row.getSpacing()
        # Store the row information in the dictionary
        d[row] = [name, spacing]
    
    return d

# Call the function to get the database rows information
db_rows_info = get_db_rows_info()","Get the rows with its name and spacing in a form of a dictionary. The key of the dictionary is the row object, the value is a list containing name and spacing of the row object"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Set the unit used in def file to 3000 as mentioned in the prompt
block.setDefUnits(3000)",Set the def units per micron to 3000
"def get_module_names():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the modules
    modules = block.getModules()
    module_names = []
    
    # Iterate through all the modules
    for module in modules:
        # Append the names of the module
        module_names.append(module.getName())
    
    return module_names

# Call the function to get the module names
module_names_list = get_module_names()",Get all the modules and return the names of modules as a list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst(""inpu1"")
inst.setUserFlag1()","Set user-defined flag 1 to ture on the instance with name ""input1"""
"def get_net_cc_adjust_factors():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the nets
    nets = block.getNets()
    adjust_factors = []
    
    # Iterate through all the nets
    for net in nets:
        # Append the capacitance coupling adjust factor of the net
        adjust_factors.append(net.getCcAdjustFactor())
    
    return adjust_factors

# Call the function to get the capacitance coupling adjust factors
net_adjust_factors = get_net_cc_adjust_factors()",Get the capacitance coupling Adjust Factor of every net and return them as a list.
"def get_net_cc_adjust_orders():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the nets
    nets = block.getNets()
    adjust_orders = []
    
    # Iterate through all the nets
    for net in nets:
        # Append the capacitance coupling adjust order of the net
        adjust_orders.append(net.getCcAdjustOrder())
    
    return adjust_orders

# Call the function to get the capacitance coupling adjust orders
net_adjust_orders = get_net_cc_adjust_orders()",Get the capacitance coupling Adjust Order of every net and return them as a list.
"def get_net_tracks():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the nets
    nets = block.getNets()
    track_list = []
    
    # Iterate through all the nets
    for net in nets:
        # Get the tracks of the net
        tracks = net.getTracks()
        # Append the tracks to the track list
        track_list.append(tracks)
    
    return track_list

# Call the function to get the tracks for all nets
net_tracks = get_net_tracks()",Get the tracks of every net as a list of lists. Each list in the output list should contain the tracks of respective net
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the instance with name 'input1' as mentioned in the prompt
inst = block.findInst(""input1"")
# Get the nets of the instance
nets = inst.getNets()
track_list = []
# Iterate through all the nets
for net in nets:
        # Get the tracks of the net
        tracks = net.getTracks()
        track_list.append(tracks)","Get the tracks of nets that are connected to instance with name ""input1"" as a list of list. Each list in the output list should contain the tracks of respective net"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the nets
nets = block.getNets()
types = []
# Iterate through all the nets
for net in nets:
        # Append the wire type of the net
        types.append(net.getWireType())",Get the wire type of each net and return them as a list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the nets
nets = block.getNets()
termsCount = []
# Iterate through all the nets
for net in nets:
        # Get term counts of the net and append to the array
        termsCount.append(net.getTermCount())",Get term count of every net and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
output = []
insts = block.getInsts()
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rise arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is greater than 0.5 second as mentioned in the prompt
                if pin_rise_arr > 0.5:
                        output.append(pin)",Get all the pins which has the rising arrival time greater than 0.5 sec and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
insts = block.getInsts()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the rising arrival time
                pin_rise_arr = timing.getPinArrival(pin, timing.Rise)
                # Check if the rising arrival time is less than or equal 0.5 second as mentioned in the prompt
                if pin_rise_arr <= 0.5:
                        output.append(pin)",Get all the pins which has the rising arrival time less than or equal to 0.5 second and return them as list
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
insts = block.getInsts()
output = []
# Iterate through all the instances
for inst in insts:
        # Get all the pins connected to the instance
        inst_ITerms = inst.getITerms()
        # Iterate through the pins
        for pin in inst_ITerms:
                if design.isInSupply(pin):
                        continue
                # Get the falling arrival time
                pin_fall_arr = timing.getPinArrival(pin, timing.Fall)
                # Check if the fall arrival time is greater than 0.8 second as mentioned in the prompt
                if pin_fall_arr > 0.8:
                        # Append the pin to the output
                        output.append(pin)",Get all the pins which has Pin Fall Arrival Time greater than 0.8 sec and return them as list
"def check_if_any_wire_altered():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the nets
    nets = block.getNets()
    
    # Iterate through all the nets
    for net in nets:
        # Check if the wire is replaced with a new wire
        if net.isWireAltered():
            return True
    
    return False

# Call the function to check if any wire is altered
is_wire_altered = check_if_any_wire_altered()",Check all the nets and check if any of its wires is replaced with a new wire. Return True if Altered and false otherwise
"def get_ports_and_nets():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the ports (which are known as BTerms in OpenROAD)
    ports = block.getBTerms()
    port_net_dict = {}
    
    # Iterate through all the ports
    for port in ports:
        # Append the name and net of the port in the dictionary
        port_net_dict[port.getName()] = port.getNet()
    
    return port_net_dict

# Call the function to get the ports and their associated nets
ports_and_nets = get_ports_and_nets()",Get all the net of ports and return a dictionay with port name as key and Net of the port as Value of the dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
# Iterate through all the ports
for port in ports:
        # Append the name and block pins objects of the port in the dictionary
        d[port.getName()] = port.getBPins()",Get all the design block pins objects of ports and return a dictionay with port name as key and pins of the port as Value of the dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the design block ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
placement_status_with_name = {}
# Iterate through all the ports
for port in ports:
        # Get the name of the port
        name = port.getName()
        # Get the placement status of the port
        status = port.getFirstPinPlacementStatus()
        # Append the placement status and name of the port to the dictionary
        placement_status_with_name[name] = status",Get the name of every design block port with the placement status of the first pin as a dictionary
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the ports (which are known of BTerms in OpenROAD)
ports = block.getBTerms()
d = {}
output = []
# Iterate through all the ports
for port in ports:
        # Append the port name and IO type of the port to the dictionary
        d[port.getName()] = port.getIoType()",Get all the I/O types of ports and return a dictionay with port name as keys and IO Type of the port as values
"def get_port_bounding_box(port_name=""req_val""):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Find the port with the specified name
    port = block.findBTerm(port_name)
    
    # Find the boundary box of the port
    BBox = port.getBBox()
    
    # Get the coordinates of the bounding box
    xmin = BBox.xMin()
    ymin = BBox.yMin()
    xmax = BBox.xMax()
    ymax = BBox.yMax()
    
    return [[xmin, ymin], [xmax, ymax]]

# Call the function to get the bounding box of the port ""req_val""
bounding_box = get_port_bounding_box()","Get the Bounding Box of a port named ""req_val"". Return a list of coordinates (Xmin, Ymin in one list and Xmax, Ymax in another list) "
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm('req_val')
# Set SPECIAL attribute to the port
port.setSpecial()",Set SPECIAL attribute port named 'req_val'
"def is_port_special(port_name):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Find the port with the specified name
    port = block.findBTerm(port_name)
    
    # Return whether the port has the SPECIAL attribute
    return port.isSpecial()

# Call the function with the argument ""req_val""
port_special_status = is_port_special('req_val')",Check if the port named 'req_val' has SPECIAL attribute
"def get_wire_updated_nets():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get all the nets
    nets = block.getNets()
    
    # Get and report wire-updated nets
    wire_updated_nets = block.getWireUpdatedNets(nets)
    
    return wire_updated_nets

# Call the function to get wire-updated nets
updated_nets = get_wire_updated_nets()",Get the of nets for any wire changes and report the statistics of the nets with changed wires.
"def get_technology_layers():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Return the technology layers
    return tech.getLayers()

# Call the function to get the technology layers
technology_layers = get_technology_layers()",Get the technolgy layers. The layers are ordered from the bottom mask number to the top mask number.
"def get_layer_count():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Return the number of layers in this technology
    return tech.getLayerCount()

# Call the function to get the layer count
layer_count = get_layer_count()",Get the number of layers in this technology.
"def get_routing_layer_count():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Return the number of routing layers in this technology
    return tech.getRoutingLayerCount()

# Call the function to get the routing layer count
routing_layer_count = get_routing_layer_count()",Get the number of routing-layers in this technology.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the number of vias in this technolgy.
viaCount = tech.getViaCount()",Get the number of vias in this technolgy.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return the via generate rules in this technolgy
viaGenerateRule = tech.getViaGenerateRules()",Get the via generate rules in this technolgy.
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get the technolgy vias. This includes non-default-rule-vias.
vias = tech.getVias()",Get the technolgy vias
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get LEF CLEARANCEMEASURE
clearanceMeasure = tech.getClearanceMeasure()",Get LEF CLEARANCEMEASURE
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Return MANUFACTURINGGRID
# NOTE: Assumes conversion to internal DB units,
# NOT microns or LEF/DEF units
ManufacturingGrid = tech.getManufacturingGrid()",Get MANUFACTURINGGRID
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the net with name ""req_msg[11]""
net = block.findNet(""req_msg[11]"")
# Set the capacitance coupling adjust factor of the net to 1
net.setCcAdjustFactor(1)","Set the capacitance coupling adjust factor of the net with name ""req_msg[11]"" to 1"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the net with name ""req_msg[11]""
net = block.findNet(""req_msg[11]"")
# Set the capacitance coupling calibration factor of the net to 2
net.setCcCalibFactor(2)","Set the capacitance coupling calibration factor of the net with name ""req_msg[11]"" to 2"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get all the nets
nets = block.getNets()
output = {}
# Iterate through all the nets
for net in nets:
        # Append the net name and capacitance coupling match ratio against the net to a dictionary
        output[net.getName()] = net.getCcMatchRatio()",Get the capacitance coupling match ratio against this nets with the name of the net. Return a dictionary with key being the name of the net and value of the dictionary is the capacitance coupling match ratio against the net
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Iterate through the net names ""req_msg[13] and ""clk"" as mentioned in the prompt
for net_name in [""req_msg[13]"", ""clk""]:
        # Find the net with net name as parameter
        net = block.findNet(net_name)
        # Set the coupling capacitance match ratio against the net to 1
        net.setCcMatchRatio(1)","Set the coupling capacitance match ratio against the net with name ""req_msg[13]"" and ""clk""  to 1"
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get the technology layers
layers = tech.getLayers()
output = []
# Iterate through all the layers
for layer in layers:
        # Get the names of the technology layers
        output.append(layer.getName())",Get the names of the technology layers
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get all the tehnology layers
layers = tech.getLayers()
output = {}
# Iterate through all the technology layers
for layer in layers:
        # Append the layer name and AREA parameter to the dictionary
        output[layer.getName()] = layer.getArea()",Get the AREA parameter of the technology layers with their name. Return a dictionary with key as the layer name and value as the AREA parameter 
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Get all the technology layers
layers = tech.getLayers()
output = {}
# Iterate through all the layers
for layer in layers:
        # Append the layer name and layer direction to the dictionary
        output[layer.getName()] = layer.getDirection()",Get the directions of the technology layers with their name. Return a dictionary with key as the layer name and value as the layer direction 
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Get the technology information
tech = block.getTech()
# Find the layer with name 'metal8'
layer = tech.findLayer('metal8')
# Return the routing layer corner spacing rule
techLayerCornerSpacingRules = layer.getTechLayerCornerSpacingRules()",Get the routing layer corner spacing rules of technology layer with name 'metal8'
"# Get the design block
block = ord.get_db_block()
# Find the instance named ""split30""
split30 = block.findInst(""split30"")",Find instance split30
"def get_instance_names():
    # Get the design block
    block = ord.get_db_block()
    
    # Get instances
    insts = block.getInsts()
    
    # Initialize a list to store instance names
    inst_names = []

    # Iterate over instances and append their names to the list
    for inst in insts:
        inst_names.append(inst.getName())
    
    return inst_names

# Call the function
instance_names = get_instance_names()",List all the instances name
"# Define the function to select nets
def get_selected_nets():
    # Get the design block
    block = design.getBlock()

    # Get all nets
    nets = block.getNets()

    # List to store selected nets
    selected_nets = []

    # Iterate through each net
    for net in nets:
        # Check if the net is selected
        if net.isSelect():
            # Append the net to the list
            selected_nets.append(net)

    return selected_nets

# Call the function
selected_nets = get_selected_nets()",Get the selected nets
"def get_cut_class_rules(layer_name='metal8'):
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    
    # Get the technology information
    tech = block.getTech()
    
    # Find the technology layer with the given name
    layer = tech.findLayer(layer_name)
    
    # Return the cut layer class rule
    return layer.getTechLayerCutClassRules()

# Calling the function with the default 'metal8' layer
cut_class_rules = get_cut_class_rules()",Get the cut layer class rule of layer with name 'metal8'
"def set_wire_type_as_routed(design, nets):
    # Get the design block
    block = design.getBlock()

    # Iterate through each net name
    for name in nets:
        # Find the net object by name
        net = block.findNet(name)
        
        # Set the wire type of the net as ROUTED
        net.setWireType('ROUTED')

# List of net names to set wire type as ROUTED
nets = [
    ""_000_"",
    ""_001_"",
    ""_002_"",
    ""_003_"",
    ""_004_"",
    ""_005_"",
    ""_006_"",
    ""_007_"",
    ""_008_"",
    ""_009_"",
    ""_010_""
]

# Assuming `design` is an object that's already available
set_wire_type_as_routed(design, nets)","Set the following nets wire type to ROUTED: _000_, _001_, _002_, _003_, _004_, _005_, _006_, _007_, _008_, _009_, _010_
"
"def get_port_signals(block=None):
    if block is None:
        block = ord.get_db_block()  # Default to current database block if no block is provided.
    
    ports = block.getBTerms()
    port_signals = {}
    
    for port in ports:
        port_signals[port.getName()] = port.getSigType()
    
    return port_signals

# Call the function
port_signals = get_port_signals()
print(port_signals)",Get the name of every block port with its signal type as a dictionary
"def check_output_pins_without_nets():
    # Get the design block
    block = ord.get_db_block()
    # Get all instances
    insts = block.getInsts()
    # Initialize a list to store output pins without nets
    outputPinWithoutNet = []

    # Iterate over instances
    for inst in insts:
        # Get all pins of the instance
        pins = inst.getITerms()
        # Iterate over pins
        for pin in pins:
            # Check if the pin is an output signal
            if pin.isOutputSignal():
                # Get the net connected to the pin
                nets = pin.getNet()
                # Check if the pin has no net connected
                if nets is None:
                    # Append the pin to the list
                    outputPinWithoutNet.append(pin)

    # Check if there are no output pins without nets
    return len(outputPinWithoutNet) == 0

# Call the function
result = check_output_pins_without_nets()
print(""No output pins without nets:"" if result else ""Output pins without nets found."")",Check if all the output pins of all instances have a valid net connection
"def get_instance_locations():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    loc = []
    for inst in insts:
        # Append the location of the instance to the list
        loc.append(inst.getLocation())
    return loc

# Call the function
locations = get_instance_locations()",Give me the location of every instance in the design and return it in a list called loc.
"def get_placement_status():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    placement_status_with_name = {}
    # Iterate over each instance in the design block
    for inst in insts:
        # Get the name of the particular instance
        name = inst.getName()
        # Get the placement status of the instance
        status = inst.getPlacementStatus()
        # Add the respective instance name and its status 
        placement_status_with_name[name] = status
    return placement_status_with_name

# Call the function
placement_status = get_placement_status()",Get the name of every instance with its placement status as a dictionary
"def get_placed_instances():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    # Retrieve all instances present in the design block
    insts = block.getInsts()
    placed_instances = []
    # Iterate over each instance in the design block
    for inst in insts:
        # Check if this instance is placed
        if inst.isPlaced() == True:
            # Append the instance name to the array
            placed_instances.append(inst.getName())
    return placed_instances

# Call the function
placed_instances_list = get_placed_instances()",Get the names of every instance which are placed and return a list of names
"def get_net_cap_res_coupling():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    # Retrieve all nets present in the design block
    nets = block.getNets()
    result = []
    # Iterate over each net in the design block
    for net in nets:
        # Check the signal type of the net
        if net.getSigType() != 'POWER' and net.getSigType() != 'GROUND':
            # Get the name of the net
            net_name = net.getName()
            # Get the total Capacitance of the net
            net_cap = net.getTotalCapacitance()
            # Get the total resistance of the net
            net_res = net.getTotalResistance()
            # Get the total coupling capacitance of the net
            net_coupling = net.getTotalCouplingCap()
            # Append the net name, net capacitance, net resistance, and net coupling
            result.append([net_name, net_cap, net_res, net_coupling])
    return result

# Call the function
net_info = get_net_cap_res_coupling()","Get the total capacitance, total resistance, Coupling Capacitance of all the nets except the nets that are connected to Ground and Power External Power Supply. Get them as list of lists, in which each list contains the net name, net capacitance, net resistance and net coupling."
"def get_nets_with_no_pins():
    # Get the current design block from the OpenROAD database
    block = ord.get_db_block()
    # Retrieve all nets present in the design block
    nets = block.getNets()
    result = []
    # Iterate over each net in the design block
    for net in nets:
        # Get the Pins of the net
        pins = net.getITerms()
        # Check if the length of the number of pins of the net is Zero
        if len(pins) == 0:
            # Append the net to the result
            result.append(net)
    return result

# Call the function
nets_with_no_pins = get_nets_with_no_pins()",Get all the nets which are not connected to any pins and return them as list.
"def flip_nand2_instances(cell_type):
    # Define the flipping function
    def flipX(value):
        if value == ""R0"":
            return ""MX""
        elif value == ""R90"":
            return ""MYR90""
        elif value == ""R180"":
            return ""MY""
        elif value == ""R270"":
            return ""MXR90""
        elif value == ""MY"":
            return ""R180""
        elif value == ""MYR90"":
            return ""R90""
        elif value == ""MX"":
            return ""R0""
        elif value == ""MXR90"":
            return ""R270""

    # Get the design block
    block = design.getBlock()

    # Get all instances in the block
    insts = block.getInsts()

    # Iterate through all instances in the block
    for inst in insts:
        # Check if the library cell type matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Horizontally flip the rotation of the instance
            orient = inst.getTransform().getOrient()
            orient = flipX(orient)
            inst.setOrient(orient)

# Call the function with the hard-coded 'NAND2_X1' cell type
flip_nand2_instances('NAND2_X1')",Horizontally flip the rotation of the instances whose library cell types are 'NAND2_X1'
"def flip_and2_instances(cell_type):
    # Define the flipping function
    def flipY(value):
        if value == ""R0"":
            return ""MY""
        elif value == ""R90"":
            return ""MXR90""
        elif value == ""R180"":
            return ""MX""
        elif value == ""R270"":
            return ""MYR90""
        elif value == ""MY"":
            return ""R0""
        elif value == ""MYR90"":
            return ""R270""
        elif value == ""MX"":
            return ""R180""
        elif value == ""MXR90"":
            return ""R90""

    # Get the design block
    block = design.getBlock()

    # Get all instances in the block
    insts = block.getInsts()

    # Iterate through all instances in the block
    for inst in insts:
        # Check if the library cell type matches the provided cell_type
        if inst.getMaster().getName() == cell_type:
            # Vertically flip the rotation of the instance
            orient = inst.getOrient()
            orient = flipY(orient)
            inst.setOrient(orient)

# Call the function with the hard-coded 'AND2_X1' cell type
flip_and2_instances('AND2_X1')",Vertically flip the rotation of the instances whose library cell types are 'AND2_X1'
"# Get the current design block from the OpenROAD database
block = ord.get_db_block()
# Find the port with name ""req_val""
port = block.findBTerm('req_val')
# Find the net with name ""req_msg[17]""
net = block.findNet('req_msg[17]')
# Connect the port and the net
port.connect(net)",Connect the port named 'req_val' and net named 'req_msg[17]'
"def swap_instance_master(instance_name, new_master_name):
    # Get the design block
    block = ord.get_db_block()
    # Get the database
    db = ord.get_db()
    # Find the instance by its name
    inst = block.findInst(instance_name)
    # Check if the required library cell exists in the database
    if db.findMaster(new_master_name) is not None:
        # Find the required library cell
        new_mast = db.findMaster(new_master_name)
        # Swap the instance's library cell with the new library cell
        inst.swapMaster(new_mast)
        return True
    else:
        return False

# Call the function with hard-coded arguments
instance_swapped = swap_instance_master(""split30"", ""BUF_X4"")",Upsize the instance split30 to BUF_X4
"def invert_transform_and_get_offset(instance_names, master_cell_name):
    # Get the design block
    block = design.getBlock()

    # Get all instances
    insts = block.getInsts()

    # Dictionary to store offset of transforms for specific instances
    inst_transform_offset = {}

    # Iterate through instances
    for inst in insts:
        # Check if the master cell name matches the provided master_cell_name
        if inst.getMaster().getName() == master_cell_name:
            # Get transform and invert
            transform = inst.getTransform()
            transform.invert()

        # Check if instance name is in the provided instance_names list
        if inst.getName() in instance_names:
            # Get transform and store offset
            transform = inst.getTransform()
            inst_transform_offset[inst.getName()] = transform.getOffset()

    return inst_transform_offset

# Call the function with hard-coded arguments
instance_offsets = invert_transform_and_get_offset(['_411_', 'input1'], 'NAND2_X1')","Invert the location and rotation of instances whose library cells are 'NAND2_X1'. Then, retrieve the location of the instances '_411_' and 'input1' and return them as a dictionary with the instance names as keys and their respective location as values."
"# Set the rotation of the instance '_411_' to 'MX'

# Get the design block
block = design.getBlock()

# Find the instance with the specified name
inst = block.findInst('_411_')

# Set the rotation of the instance to 'MX'
transform = inst.getTransform()
transform.setOrient('MX')
inst.setTransform(transform)",Set the rotation of the instance '_411_' to 'MX'
"def get_input_pins_for_instance(instance_name):
    # Get the design block
    block = design.getBlock()

    # Find the instance by name
    inst = block.findInst(instance_name)

    # Initialize a list to store the input pins of the instance
    input_pins = []

    # Obtain all pins associated with this instance
    pins = inst.getITerms()

    # Iterate through each pin of the instance
    for pin in pins:
        # Check if the pin represents an input signal
        if pin.isInputSignal() and pin:
            # Append the input pin to the list of input pins
            input_pins.append(pin)

    return input_pins

# Call the function with the hard-coded 'output53' instance name
input_pins_for_output53 = get_input_pins_for_instance('output53')",get the input pins of the instance 'output53'
"# Get the design block
block = ord.get_db_block()
# Find the instance ""_split30_""
inst = block.findInst(""_split30_"")
# Set the instance as don't touch type
inst.setDoNotTouch(False)","Reset the instance ""_split30_"" as don't touch type"